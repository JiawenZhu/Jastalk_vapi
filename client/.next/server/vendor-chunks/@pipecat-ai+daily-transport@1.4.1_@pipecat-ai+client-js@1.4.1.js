"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pipecat-ai+daily-transport@1.4.1_@pipecat-ai+client-js@1.4.1";
exports.ids = ["vendor-chunks/@pipecat-ai+daily-transport@1.4.1_@pipecat-ai+client-js@1.4.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@pipecat-ai+daily-transport@1.4.1_@pipecat-ai+client-js@1.4.1/node_modules/@pipecat-ai/daily-transport/dist/index.module.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@pipecat-ai+daily-transport@1.4.1_@pipecat-ai+client-js@1.4.1/node_modules/@pipecat-ai/daily-transport/dist/index.module.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DailyRTVIMessageType: () => (/* binding */ $683f111f61e07358$export$ef180de88fd317cc),\n/* harmony export */   DailyTransport: () => (/* binding */ $683f111f61e07358$export$b1ca982aa1e488c1)\n/* harmony export */ });\n/* harmony import */ var _daily_co_daily_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @daily-co/daily-js */ \"(ssr)/./node_modules/.pnpm/@daily-co+daily-js@0.84.0/node_modules/@daily-co/daily-js/dist/daily-esm.js\");\n/* harmony import */ var _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pipecat-ai/client-js */ \"(ssr)/./node_modules/.pnpm/@pipecat-ai+client-js@1.4.1/node_modules/@pipecat-ai/client-js/dist/index.module.js\");\n\n\n\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $683f111f61e07358$exports = {};\n\n$parcel$export($683f111f61e07358$exports, \"DailyRTVIMessageType\", () => $683f111f61e07358$export$ef180de88fd317cc);\n$parcel$export($683f111f61e07358$exports, \"DailyTransport\", () => $683f111f61e07358$export$b1ca982aa1e488c1);\n\n\n/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */ /**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */ class $6d4b7449a1e1544a$export$13afda237b1c9846 {\n    /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */ static floatTo16BitPCM(float32Array) {\n        const buffer = new ArrayBuffer(float32Array.length * 2);\n        const view = new DataView(buffer);\n        let offset = 0;\n        for(let i = 0; i < float32Array.length; i++, offset += 2){\n            let s = Math.max(-1, Math.min(1, float32Array[i]));\n            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n        return buffer;\n    }\n    /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */ static mergeBuffers(leftBuffer, rightBuffer) {\n        const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);\n        tmpArray.set(new Uint8Array(leftBuffer), 0);\n        tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n        return tmpArray.buffer;\n    }\n    /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */ _packData(size, arg) {\n        return [\n            new Uint8Array([\n                arg,\n                arg >> 8\n            ]),\n            new Uint8Array([\n                arg,\n                arg >> 8,\n                arg >> 16,\n                arg >> 24\n            ])\n        ][size];\n    }\n    /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */ pack(sampleRate, audio) {\n        if (!audio?.bitsPerSample) throw new Error(`Missing \"bitsPerSample\"`);\n        else if (!audio?.channels) throw new Error(`Missing \"channels\"`);\n        else if (!audio?.data) throw new Error(`Missing \"data\"`);\n        const { bitsPerSample: bitsPerSample, channels: channels, data: data } = audio;\n        const output = [\n            // Header\n            'RIFF',\n            this._packData(1, 52),\n            'WAVE',\n            // chunk 1\n            'fmt ',\n            this._packData(1, 16),\n            this._packData(0, 1),\n            this._packData(0, channels.length),\n            this._packData(1, sampleRate),\n            this._packData(1, sampleRate * channels.length * bitsPerSample / 8),\n            this._packData(0, channels.length * bitsPerSample / 8),\n            this._packData(0, bitsPerSample),\n            // chunk 2\n            'data',\n            this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),\n            data\n        ];\n        const blob = new Blob(output, {\n            type: 'audio/mpeg'\n        });\n        const url = URL.createObjectURL(blob);\n        return {\n            blob: blob,\n            url: url,\n            channelCount: channels.length,\n            sampleRate: sampleRate,\n            duration: data.byteLength / (channels.length * sampleRate * 2)\n        };\n    }\n}\nglobalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c9846;\n\n\n/**\n * Constants for help with visualization\n * Helps map frequency ranges from Fast Fourier Transform\n * to human-interpretable ranges, notably music ranges and\n * human vocal ranges.\n */ // Eighth octave frequencies\nconst $03f71ce85e00ada6$var$octave8Frequencies = [\n    4186.01,\n    4434.92,\n    4698.63,\n    4978.03,\n    5274.04,\n    5587.65,\n    5919.91,\n    6271.93,\n    6644.88,\n    7040.0,\n    7458.62,\n    7902.13\n];\n// Labels for each of the above frequencies\nconst $03f71ce85e00ada6$var$octave8FrequencyLabels = [\n    'C',\n    'C#',\n    'D',\n    'D#',\n    'E',\n    'F',\n    'F#',\n    'G',\n    'G#',\n    'A',\n    'A#',\n    'B'\n];\nconst $03f71ce85e00ada6$export$776c63898ae5b636 = [];\nconst $03f71ce85e00ada6$export$facd167cc27ea9b0 = [];\nfor(let i = 1; i <= 8; i++)for(let f = 0; f < $03f71ce85e00ada6$var$octave8Frequencies.length; f++){\n    const freq = $03f71ce85e00ada6$var$octave8Frequencies[f];\n    $03f71ce85e00ada6$export$776c63898ae5b636.push(freq / Math.pow(2, 8 - i));\n    $03f71ce85e00ada6$export$facd167cc27ea9b0.push($03f71ce85e00ada6$var$octave8FrequencyLabels[f] + i);\n}\n/**\n * Subset of the note frequencies between 32 and 2000 Hz\n * 6 octave range: C1 to B6\n */ const $03f71ce85e00ada6$var$voiceFrequencyRange = [\n    32.0,\n    2000.0\n];\nconst $03f71ce85e00ada6$export$dbc1581ed2cfa183 = $03f71ce85e00ada6$export$776c63898ae5b636.filter((_, i)=>{\n    return $03f71ce85e00ada6$export$776c63898ae5b636[i] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];\n});\nconst $03f71ce85e00ada6$export$30a6f2881311088f = $03f71ce85e00ada6$export$facd167cc27ea9b0.filter((_, i)=>{\n    return $03f71ce85e00ada6$export$776c63898ae5b636[i] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];\n});\n\n\nclass $f32f064564ee62f6$export$2c3136da0bf130f9 {\n    /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */ static getFrequencies(analyser, sampleRate, fftResult, analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n        if (!fftResult) {\n            fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n        }\n        const nyquistFrequency = sampleRate / 2;\n        const frequencyStep = 1 / fftResult.length * nyquistFrequency;\n        let outputValues;\n        let frequencies;\n        let labels;\n        if (analysisType === 'music' || analysisType === 'voice') {\n            const useFrequencies = analysisType === 'voice' ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);\n            const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n            for(let i = 0; i < fftResult.length; i++){\n                const frequency = i * frequencyStep;\n                const amplitude = fftResult[i];\n                for(let n = useFrequencies.length - 1; n >= 0; n--)if (frequency > useFrequencies[n]) {\n                    aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n                    break;\n                }\n            }\n            outputValues = aggregateOutput;\n            frequencies = analysisType === 'voice' ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);\n            labels = analysisType === 'voice' ? (0, $03f71ce85e00ada6$export$30a6f2881311088f) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b0);\n        } else {\n            outputValues = Array.from(fftResult);\n            frequencies = outputValues.map((_, i)=>frequencyStep * i);\n            labels = frequencies.map((f)=>`${f.toFixed(2)} Hz`);\n        }\n        // We normalize to {0, 1}\n        const normalizedOutput = outputValues.map((v)=>{\n            return Math.max(0, Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1));\n        });\n        const values = new Float32Array(normalizedOutput);\n        return {\n            values: values,\n            frequencies: frequencies,\n            labels: labels\n        };\n    }\n    /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */ constructor(audioElement, audioBuffer = null){\n        this.fftResults = [];\n        if (audioBuffer) {\n            /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */ const { length: length, sampleRate: sampleRate } = audioBuffer;\n            const offlineAudioContext = new OfflineAudioContext({\n                length: length,\n                sampleRate: sampleRate\n            });\n            const source = offlineAudioContext.createBufferSource();\n            source.buffer = audioBuffer;\n            const analyser = offlineAudioContext.createAnalyser();\n            analyser.fftSize = 8192;\n            analyser.smoothingTimeConstant = 0.1;\n            source.connect(analyser);\n            // limit is :: 128 / sampleRate;\n            // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n            const renderQuantumInSeconds = 1 / 60;\n            const durationInSeconds = length / sampleRate;\n            const analyze = (index)=>{\n                const suspendTime = renderQuantumInSeconds * index;\n                if (suspendTime < durationInSeconds) offlineAudioContext.suspend(suspendTime).then(()=>{\n                    const fftResult = new Float32Array(analyser.frequencyBinCount);\n                    analyser.getFloatFrequencyData(fftResult);\n                    this.fftResults.push(fftResult);\n                    analyze(index + 1);\n                });\n                if (index === 1) offlineAudioContext.startRendering();\n                else offlineAudioContext.resume();\n            };\n            source.start(0);\n            analyze(1);\n            this.audio = audioElement;\n            this.context = offlineAudioContext;\n            this.analyser = analyser;\n            this.sampleRate = sampleRate;\n            this.audioBuffer = audioBuffer;\n        } else {\n            const audioContext = new AudioContext();\n            const track = audioContext.createMediaElementSource(audioElement);\n            const analyser = audioContext.createAnalyser();\n            analyser.fftSize = 8192;\n            analyser.smoothingTimeConstant = 0.1;\n            track.connect(analyser);\n            analyser.connect(audioContext.destination);\n            this.audio = audioElement;\n            this.context = audioContext;\n            this.analyser = analyser;\n            this.sampleRate = this.context.sampleRate;\n            this.audioBuffer = null;\n        }\n    }\n    /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n        let fftResult = null;\n        if (this.audioBuffer && this.fftResults.length) {\n            const pct = this.audio.currentTime / this.audio.duration;\n            const index = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);\n            fftResult = this.fftResults[index];\n        }\n        return $f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */ async resumeIfSuspended() {\n        if (this.context.state === 'suspended') await this.context.resume();\n        return true;\n    }\n}\nglobalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f9;\n\n\nconst $29a8a70a9466b14f$export$50b76700e2b15e9 = `\nclass StreamProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.hasStarted = false;\n    this.hasInterrupted = false;\n    this.outputBuffers = [];\n    this.bufferLength = 128;\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\n    this.writeOffset = 0;\n    this.trackSampleOffsets = {};\n    this.port.onmessage = (event) => {\n      if (event.data) {\n        const payload = event.data;\n        if (payload.event === 'write') {\n          const int16Array = payload.buffer;\n          const float32Array = new Float32Array(int16Array.length);\n          for (let i = 0; i < int16Array.length; i++) {\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\n          }\n          this.writeData(float32Array, payload.trackId);\n        } else if (\n          payload.event === 'offset' ||\n          payload.event === 'interrupt'\n        ) {\n          const requestId = payload.requestId;\n          const trackId = this.write.trackId;\n          const offset = this.trackSampleOffsets[trackId] || 0;\n          this.port.postMessage({\n            event: 'offset',\n            requestId,\n            trackId,\n            offset,\n          });\n          if (payload.event === 'interrupt') {\n            this.hasInterrupted = true;\n          }\n        } else {\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\n        }\n      }\n    };\n  }\n\n  writeData(float32Array, trackId = null) {\n    let { buffer } = this.write;\n    let offset = this.writeOffset;\n    for (let i = 0; i < float32Array.length; i++) {\n      buffer[offset++] = float32Array[i];\n      if (offset >= buffer.length) {\n        this.outputBuffers.push(this.write);\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\n        buffer = this.write.buffer;\n        offset = 0;\n      }\n    }\n    this.writeOffset = offset;\n    return true;\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannelData = output[0];\n    const outputBuffers = this.outputBuffers;\n    if (this.hasInterrupted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else if (outputBuffers.length) {\n      this.hasStarted = true;\n      const { buffer, trackId } = outputBuffers.shift();\n      for (let i = 0; i < outputChannelData.length; i++) {\n        outputChannelData[i] = buffer[i] || 0;\n      }\n      if (trackId) {\n        this.trackSampleOffsets[trackId] =\n          this.trackSampleOffsets[trackId] || 0;\n        this.trackSampleOffsets[trackId] += buffer.length;\n      }\n      return true;\n    } else if (this.hasStarted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n`;\nconst $29a8a70a9466b14f$var$script = new Blob([\n    $29a8a70a9466b14f$export$50b76700e2b15e9\n], {\n    type: 'application/javascript'\n});\nconst $29a8a70a9466b14f$var$src = URL.createObjectURL($29a8a70a9466b14f$var$script);\nconst $29a8a70a9466b14f$export$bfa8c596114d74df = $29a8a70a9466b14f$var$src;\n\n\n\nclass $d0a969833958d9e7$export$9698d62c78b8f366 {\n    /**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */ constructor({ sampleRate: sampleRate = 44100 } = {}){\n        this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df);\n        this.sampleRate = sampleRate;\n        this.context = null;\n        this.stream = null;\n        this.analyser = null;\n        this.trackSampleOffsets = {};\n        this.interruptedTrackIds = {};\n    }\n    /**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */ async connect() {\n        this.context = new AudioContext({\n            sampleRate: this.sampleRate\n        });\n        if (this._speakerID) this.context.setSinkId(this._speakerID);\n        if (this.context.state === \"suspended\") await this.context.resume();\n        try {\n            await this.context.audioWorklet.addModule(this.scriptSrc);\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n        }\n        const analyser = this.context.createAnalyser();\n        analyser.fftSize = 8192;\n        analyser.smoothingTimeConstant = 0.1;\n        this.analyser = analyser;\n        return true;\n    }\n    /**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = \"frequency\", minDecibels = -100, maxDecibels = -30) {\n        if (!this.analyser) throw new Error(\"Not connected, please call .connect() first\");\n        return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * @param {string} speaker deviceId\n   */ async updateSpeaker(speaker) {\n        const _prevSpeaker = this._speakerID;\n        this._speakerID = speaker;\n        if (this.context) try {\n            if (speaker === \"default\") await this.context.setSinkId();\n            else await this.context.setSinkId(speaker);\n        } catch (e) {\n            console.error(`Could not set sinkId to ${speaker}: ${e}`);\n            this._speakerID = _prevSpeaker;\n        }\n    }\n    /**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */ _start() {\n        const streamNode = new AudioWorkletNode(this.context, \"stream_processor\");\n        streamNode.connect(this.context.destination);\n        streamNode.port.onmessage = (e)=>{\n            const { event: event } = e.data;\n            if (event === \"stop\") {\n                streamNode.disconnect();\n                this.stream = null;\n            } else if (event === \"offset\") {\n                const { requestId: requestId, trackId: trackId, offset: offset } = e.data;\n                const currentTime = offset / this.sampleRate;\n                this.trackSampleOffsets[requestId] = {\n                    trackId: trackId,\n                    offset: offset,\n                    currentTime: currentTime\n                };\n            }\n        };\n        this.analyser.disconnect();\n        streamNode.connect(this.analyser);\n        this.stream = streamNode;\n        return true;\n    }\n    /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */ add16BitPCM(arrayBuffer, trackId = \"default\") {\n        if (typeof trackId !== \"string\") throw new Error(`trackId must be a string`);\n        else if (this.interruptedTrackIds[trackId]) return;\n        if (!this.stream) this._start();\n        let buffer;\n        if (arrayBuffer instanceof Int16Array) buffer = arrayBuffer;\n        else if (arrayBuffer instanceof ArrayBuffer) buffer = new Int16Array(arrayBuffer);\n        else throw new Error(`argument must be Int16Array or ArrayBuffer`);\n        this.stream.port.postMessage({\n            event: \"write\",\n            buffer: buffer,\n            trackId: trackId\n        });\n        return buffer;\n    }\n    /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */ async getTrackSampleOffset(interrupt = false) {\n        if (!this.stream) return null;\n        const requestId = crypto.randomUUID();\n        this.stream.port.postMessage({\n            event: interrupt ? \"interrupt\" : \"offset\",\n            requestId: requestId\n        });\n        let trackSampleOffset;\n        while(!trackSampleOffset){\n            trackSampleOffset = this.trackSampleOffsets[requestId];\n            await new Promise((r)=>setTimeout(()=>r(), 1));\n        }\n        const { trackId: trackId } = trackSampleOffset;\n        if (interrupt && trackId) this.interruptedTrackIds[trackId] = true;\n        return trackSampleOffset;\n    }\n    /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */ async interrupt() {\n        return this.getTrackSampleOffset(true);\n    }\n}\nglobalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f366;\n\n\nconst $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet = `\nclass AudioProcessor extends AudioWorkletProcessor {\n\n  constructor() {\n    super();\n    this.port.onmessage = this.receive.bind(this);\n    this.initialize();\n  }\n\n  initialize() {\n    this.foundAudio = false;\n    this.recording = false;\n    this.chunks = [];\n  }\n\n  /**\n   * Concatenates sampled chunks into channels\n   * Format is chunk[Left[], Right[]]\n   */\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\n    let channelLimit;\n    if (channel !== -1) {\n      if (chunks[0] && chunks[0].length - 1 < channel) {\n        throw new Error(\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\n        );\n      }\n      channelLimit = channel + 1;\n    } else {\n      channel = 0;\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n    }\n    const channels = [];\n    for (let n = channel; n < channelLimit; n++) {\n      const length = chunks.reduce((sum, chunk) => {\n        return sum + chunk[n].length;\n      }, 0);\n      const buffers = chunks.map((chunk) => chunk[n]);\n      const result = new Float32Array(length);\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        result.set(buffers[i], offset);\n        offset += buffers[i].length;\n      }\n      channels[n] = result;\n    }\n    return channels;\n  }\n\n  /**\n   * Combines parallel audio data into correct format,\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\n   */\n  formatAudioData(channels) {\n    if (channels.length === 1) {\n      // Simple case is only one channel\n      const float32Array = channels[0].slice();\n      const meanValues = channels[0].slice();\n      return { float32Array, meanValues };\n    } else {\n      const float32Array = new Float32Array(\n        channels[0].length * channels.length\n      );\n      const meanValues = new Float32Array(channels[0].length);\n      for (let i = 0; i < channels[0].length; i++) {\n        const offset = i * channels.length;\n        let meanValue = 0;\n        for (let n = 0; n < channels.length; n++) {\n          float32Array[offset + n] = channels[n][i];\n          meanValue += channels[n][i];\n        }\n        meanValues[i] = meanValue / channels.length;\n      }\n      return { float32Array, meanValues };\n    }\n  }\n\n  /**\n   * Converts 32-bit float data to 16-bit integers\n   */\n  floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Retrieves the most recent amplitude values from the audio stream\n   * @param {number} channel\n   */\n  getValues(channel = -1) {\n    const channels = this.readChannelData(this.chunks, channel);\n    const { meanValues } = this.formatAudioData(channels);\n    return { meanValues, channels };\n  }\n\n  /**\n   * Exports chunks as an audio/wav file\n   */\n  export() {\n    const channels = this.readChannelData(this.chunks);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const audioData = this.floatTo16BitPCM(float32Array);\n    return {\n      meanValues: meanValues,\n      audio: {\n        bitsPerSample: 16,\n        channels: channels,\n        data: audioData,\n      },\n    };\n  }\n\n  receive(e) {\n    const { event, id } = e.data;\n    let receiptData = {};\n    switch (event) {\n      case 'start':\n        this.recording = true;\n        break;\n      case 'stop':\n        this.recording = false;\n        break;\n      case 'clear':\n        this.initialize();\n        break;\n      case 'export':\n        receiptData = this.export();\n        break;\n      case 'read':\n        receiptData = this.getValues();\n        break;\n      default:\n        break;\n    }\n    // Always send back receipt\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\n  }\n\n  sendChunk(chunk) {\n    const channels = this.readChannelData([chunk]);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\n    this.port.postMessage({\n      event: 'chunk',\n      data: {\n        mono: monoAudioData,\n        raw: rawAudioData,\n      },\n    });\n  }\n\n  process(inputList, outputList, parameters) {\n    // Copy input to output (e.g. speakers)\n    // Note that this creates choppy sounds with Mac products\n    const sourceLimit = Math.min(inputList.length, outputList.length);\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\n      const input = inputList[inputNum];\n      const output = outputList[inputNum];\n      const channelCount = Math.min(input.length, output.length);\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\n        input[channelNum].forEach((sample, i) => {\n          output[channelNum][i] = sample;\n        });\n      }\n    }\n    const inputs = inputList[0];\n    // There's latency at the beginning of a stream before recording starts\n    // Make sure we actually receive audio data before we start storing chunks\n    let sliceIndex = 0;\n    if (!this.foundAudio) {\n      for (const channel of inputs) {\n        sliceIndex = 0; // reset for each channel\n        if (this.foundAudio) {\n          break;\n        }\n        if (channel) {\n          for (const value of channel) {\n            if (value !== 0) {\n              // find only one non-zero entry in any channel\n              this.foundAudio = true;\n              break;\n            } else {\n              sliceIndex++;\n            }\n          }\n        }\n      }\n    }\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\n      // We need to copy the TypedArray, because the \\`process\\`\n      // internals will reuse the same buffer to hold each input\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\n      this.chunks.push(chunk);\n      this.sendChunk(chunk);\n    }\n    return true;\n  }\n}\n\nregisterProcessor('audio_processor', AudioProcessor);\n`;\nconst $8e1d1e6ff08f6fb5$var$script = new Blob([\n    $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet\n], {\n    type: 'application/javascript'\n});\nconst $8e1d1e6ff08f6fb5$var$src = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script);\nconst $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c = $8e1d1e6ff08f6fb5$var$src;\n\n\n\n\nclass $62bc376044a05513$export$439b217ca659a877 {\n    /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */ constructor({ sampleRate: sampleRate = 44100, outputToSpeakers: outputToSpeakers = false, debug: debug = false } = {}){\n        // Script source\n        this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);\n        // Config\n        this.sampleRate = sampleRate;\n        this.outputToSpeakers = outputToSpeakers;\n        this.debug = !!debug;\n        this._deviceChangeCallback = null;\n        this._deviceErrorCallback = null;\n        this._devices = [];\n        this.deviceSelection = null;\n        // State variables\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        this.recording = false;\n        // Event handling with AudioWorklet\n        this._lastEventId = 0;\n        this.eventReceipts = {};\n        this.eventTimeout = 5000;\n        // Process chunks of audio\n        this._chunkProcessor = ()=>{};\n        this._chunkProcessorSize = void 0;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n    }\n    /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */ static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n        const context = new AudioContext({\n            sampleRate: sampleRate\n        });\n        let arrayBuffer;\n        let blob;\n        if (audioData instanceof Blob) {\n            if (fromSampleRate !== -1) throw new Error(`Can not specify \"fromSampleRate\" when reading from Blob`);\n            blob = audioData;\n            arrayBuffer = await blob.arrayBuffer();\n        } else if (audioData instanceof ArrayBuffer) {\n            if (fromSampleRate !== -1) throw new Error(`Can not specify \"fromSampleRate\" when reading from ArrayBuffer`);\n            arrayBuffer = audioData;\n            blob = new Blob([\n                arrayBuffer\n            ], {\n                type: 'audio/wav'\n            });\n        } else {\n            let float32Array;\n            let data;\n            if (audioData instanceof Int16Array) {\n                data = audioData;\n                float32Array = new Float32Array(audioData.length);\n                for(let i = 0; i < audioData.length; i++)float32Array[i] = audioData[i] / 0x8000;\n            } else if (audioData instanceof Float32Array) float32Array = audioData;\n            else if (audioData instanceof Array) float32Array = new Float32Array(audioData);\n            else throw new Error(`\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);\n            if (fromSampleRate === -1) throw new Error(`Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`);\n            else if (fromSampleRate < 3000) throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n            if (!data) data = (0, $6d4b7449a1e1544a$export$13afda237b1c9846).floatTo16BitPCM(float32Array);\n            const audio = {\n                bitsPerSample: 16,\n                channels: [\n                    float32Array\n                ],\n                data: data\n            };\n            const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n            const result = packer.pack(fromSampleRate, audio);\n            blob = result.blob;\n            arrayBuffer = await blob.arrayBuffer();\n        }\n        const audioBuffer = await context.decodeAudioData(arrayBuffer);\n        const values = audioBuffer.getChannelData(0);\n        const url = URL.createObjectURL(blob);\n        return {\n            blob: blob,\n            url: url,\n            values: values,\n            audioBuffer: audioBuffer\n        };\n    }\n    /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */ log() {\n        if (this.debug) this.log(...arguments);\n        return true;\n    }\n    /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */ getSampleRate() {\n        return this.sampleRate;\n    }\n    /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */ getStatus() {\n        if (!this.processor) return 'ended';\n        else if (!this.recording) return 'paused';\n        else return 'recording';\n    }\n    /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */ async _event(name, data = {}, _processor = null) {\n        _processor = _processor || this.processor;\n        if (!_processor) throw new Error('Can not send events without recording first');\n        const message = {\n            event: name,\n            id: this._lastEventId++,\n            data: data\n        };\n        _processor.port.postMessage(message);\n        const t0 = new Date().valueOf();\n        while(!this.eventReceipts[message.id]){\n            if (new Date().valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for \"${name}\" event`);\n            await new Promise((res)=>setTimeout(()=>res(true), 1));\n        }\n        const payload = this.eventReceipts[message.id];\n        delete this.eventReceipts[message.id];\n        return payload;\n    }\n    /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */ listenForDeviceChange(callback) {\n        if (callback === null && this._deviceChangeCallback) {\n            navigator.mediaDevices.removeEventListener('devicechange', this._deviceChangeCallback);\n            this._deviceChangeCallback = null;\n        } else if (callback !== null) {\n            // Basically a debounce; we only want this called once when devices change\n            // And we only want the most recent callback() to be executed\n            // if a few are operating at the same time\n            let lastId = 0;\n            let lastDevices = [];\n            const serializeDevices = (devices)=>devices.map((d)=>d.deviceId).sort().join(',');\n            const cb = async ()=>{\n                let id = ++lastId;\n                const devices = await this.listDevices();\n                if (id === lastId) {\n                    if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n                        lastDevices = devices;\n                        callback(devices.slice());\n                    }\n                }\n            };\n            navigator.mediaDevices.addEventListener('devicechange', cb);\n            cb();\n            this._deviceChangeCallback = cb;\n        }\n        return true;\n    }\n    /**\n   * Provide a callback for if/when device errors occur\n   * @param {(({devices: Array<\"cam\" | \"mic\">, type: string, error?: Error}) => void) | null} callback\n   * @returns {true}\n   */ listenForDeviceErrors(callback) {\n        this._deviceErrorCallback = callback;\n    }\n    /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */ async requestPermission() {\n        const permissionStatus = await navigator.permissions.query({\n            name: 'microphone'\n        });\n        if (permissionStatus.state === 'denied') {\n            if (this._deviceErrorCallback) this._deviceErrorCallback({\n                devices: [\n                    \"mic\"\n                ],\n                type: \"unknown\",\n                error: new Error(\"Microphone access denied\")\n            });\n        } else if (permissionStatus.state === 'prompt') try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true\n            });\n            const tracks = stream.getTracks();\n            tracks.forEach((track)=>track.stop());\n        } catch (e) {\n            console.error(\"Error accessing microphone.\");\n            if (this._deviceErrorCallback) this._deviceErrorCallback({\n                devices: [\n                    \"mic\"\n                ],\n                type: \"unknown\",\n                error: e\n            });\n        }\n        return true;\n    }\n    /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */ async listDevices() {\n        if (!navigator.mediaDevices || !('enumerateDevices' in navigator.mediaDevices)) throw new Error('Could not request user devices');\n        await this.requestPermission();\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const audioDevices = devices.filter((device)=>device.kind === 'audioinput');\n        return audioDevices;\n    // const defaultDeviceIndex = audioDevices.findIndex(\n    //   (device) => device.deviceId === 'default'\n    // );\n    // const deviceList = [];\n    // if (defaultDeviceIndex !== -1) {\n    //   let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n    //   let existingIndex = audioDevices.findIndex(\n    //     (device) => device.groupId === defaultDevice.groupId\n    //   );\n    //   if (existingIndex !== -1) {\n    //     defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n    //   }\n    //   defaultDevice.default = true;\n    //   deviceList.push(defaultDevice);\n    // }\n    // return deviceList.concat(audioDevices);\n    }\n    /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */ async begin(deviceId) {\n        if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);\n        if (!navigator.mediaDevices || !('getUserMedia' in navigator.mediaDevices)) {\n            if (this._deviceErrorCallback) this._deviceErrorCallback({\n                devices: [\n                    \"mic\",\n                    \"cam\"\n                ],\n                type: \"undefined-mediadevices\"\n            });\n            throw new Error('Could not request user media');\n        }\n        deviceId = deviceId ?? this.deviceSelection?.deviceId;\n        try {\n            const config = {\n                audio: true\n            };\n            if (deviceId) config.audio = {\n                deviceId: {\n                    exact: deviceId\n                }\n            };\n            this.stream = await navigator.mediaDevices.getUserMedia(config);\n        } catch (err) {\n            if (this._deviceErrorCallback) this._deviceErrorCallback({\n                devices: [\n                    \"mic\"\n                ],\n                type: \"unknown\",\n                error: err\n            });\n            throw new Error('Could not start media stream');\n        }\n        this.listDevices().then((devices)=>{\n            deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;\n            console.log('find current device', devices, deviceId, this.stream.getAudioTracks()[0].getSettings());\n            this.deviceSelection = devices.find((d)=>d.deviceId === deviceId);\n            console.log('current device', this.deviceSelection);\n        });\n        const context = new AudioContext({\n            sampleRate: this.sampleRate\n        });\n        const source = context.createMediaStreamSource(this.stream);\n        // Load and execute the module script.\n        try {\n            await context.audioWorklet.addModule(this.scriptSrc);\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n        }\n        const processor = new AudioWorkletNode(context, 'audio_processor');\n        processor.port.onmessage = (e)=>{\n            const { event: event, id: id, data: data } = e.data;\n            if (event === 'receipt') this.eventReceipts[id] = data;\n            else if (event === 'chunk') {\n                if (this._chunkProcessorSize) {\n                    const buffer = this._chunkProcessorBuffer;\n                    this._chunkProcessorBuffer = {\n                        raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),\n                        mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)\n                    };\n                    if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {\n                        this._chunkProcessor(this._chunkProcessorBuffer);\n                        this._chunkProcessorBuffer = {\n                            raw: new ArrayBuffer(0),\n                            mono: new ArrayBuffer(0)\n                        };\n                    }\n                } else this._chunkProcessor(data);\n            }\n        };\n        const node = source.connect(processor);\n        const analyser = context.createAnalyser();\n        analyser.fftSize = 8192;\n        analyser.smoothingTimeConstant = 0.1;\n        node.connect(analyser);\n        if (this.outputToSpeakers) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Warning: Output to speakers may affect sound quality,\\nespecially due to system audio feedback preventative measures.\\nuse only for debugging\");\n            analyser.connect(context.destination);\n        }\n        this.source = source;\n        this.node = node;\n        this.analyser = analyser;\n        this.processor = processor;\n        console.log('begin completed');\n        return true;\n    }\n    /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */ async pause() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        else if (!this.recording) throw new Error('Already paused: please call .record() first');\n        if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);\n        this.log('Pausing ...');\n        await this._event('stop');\n        this.recording = false;\n        return true;\n    }\n    /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */ async record(chunkProcessor = ()=>{}, chunkSize = 8192) {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        else if (this.recording) throw new Error('Already recording: please call .pause() first');\n        else if (typeof chunkProcessor !== 'function') throw new Error(`chunkProcessor must be a function`);\n        this._chunkProcessor = chunkProcessor;\n        this._chunkProcessorSize = chunkSize;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n        this.log('Recording ...');\n        await this._event('start');\n        this.recording = true;\n        return true;\n    }\n    /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */ async clear() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        await this._event('clear');\n        return true;\n    }\n    /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */ async read() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        this.log('Reading ...');\n        const result = await this._event('read');\n        return result;\n    }\n    /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async save(force = false) {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        if (!force && this.recording) throw new Error('Currently recording: please call .pause() first, or call .save(true) to force');\n        this.log('Exporting ...');\n        const exportData = await this._event('export');\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async end() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        const _processor = this.processor;\n        this.log('Stopping ...');\n        await this._event('stop');\n        this.recording = false;\n        const tracks = this.stream.getTracks();\n        tracks.forEach((track)=>track.stop());\n        this.log('Exporting ...');\n        const exportData = await this._event('export', {}, _processor);\n        this.processor.disconnect();\n        this.source.disconnect();\n        this.node.disconnect();\n        this.analyser.disconnect();\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */ async quit() {\n        this.listenForDeviceChange(null);\n        // we do not reset this on end so that selections persist across starts\n        this.deviceSelection = null;\n        if (this.processor) await this.end();\n        return true;\n    }\n}\nglobalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a877;\n\n\n\n\n\nclass $5fc11d7bc0d20724$export$2934cf2d25c67a48 {\n    /**\n   * Create a new MediaStreamRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {MediaStreamRecorder}\n   */ constructor({ sampleRate: sampleRate = 44100, outputToSpeakers: outputToSpeakers = false, debug: debug = false } = {}){\n        // Script source\n        this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);\n        // Config\n        this.sampleRate = sampleRate;\n        this.outputToSpeakers = outputToSpeakers;\n        this.debug = !!debug;\n        // State variables\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        this.recording = false;\n        // Event handling with AudioWorklet\n        this._lastEventId = 0;\n        this.eventReceipts = {};\n        this.eventTimeout = 5000;\n        // Process chunks of audio\n        this._chunkProcessor = ()=>{};\n        this._chunkProcessorSize = void 0;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n    }\n    /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */ log() {\n        if (this.debug) this.log(...arguments);\n        return true;\n    }\n    /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */ getSampleRate() {\n        return this.sampleRate;\n    }\n    /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */ getStatus() {\n        if (!this.processor) return \"ended\";\n        else if (!this.recording) return \"paused\";\n        else return \"recording\";\n    }\n    /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */ async _event(name, data = {}, _processor = null) {\n        _processor = _processor || this.processor;\n        if (!_processor) throw new Error(\"Can not send events without recording first\");\n        const message = {\n            event: name,\n            id: this._lastEventId++,\n            data: data\n        };\n        _processor.port.postMessage(message);\n        const t0 = new Date().valueOf();\n        while(!this.eventReceipts[message.id]){\n            if (new Date().valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for \"${name}\" event`);\n            await new Promise((res)=>setTimeout(()=>res(true), 1));\n        }\n        const payload = this.eventReceipts[message.id];\n        delete this.eventReceipts[message.id];\n        return payload;\n    }\n    /**\n   * Begins a recording session for the given audioTrack\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */ async begin(audioTrack) {\n        if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);\n        if (!audioTrack || audioTrack.kind !== \"audio\") throw new Error(\"No audio track provided\");\n        this.stream = new MediaStream([\n            audioTrack\n        ]);\n        const context = new AudioContext({\n            sampleRate: this.sampleRate\n        });\n        const source = context.createMediaStreamSource(this.stream);\n        // Load and execute the module script.\n        try {\n            await context.audioWorklet.addModule(this.scriptSrc);\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n        }\n        const processor = new AudioWorkletNode(context, \"audio_processor\");\n        processor.port.onmessage = (e)=>{\n            const { event: event, id: id, data: data } = e.data;\n            if (event === \"receipt\") this.eventReceipts[id] = data;\n            else if (event === \"chunk\") {\n                if (this._chunkProcessorSize) {\n                    const buffer = this._chunkProcessorBuffer;\n                    this._chunkProcessorBuffer = {\n                        raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),\n                        mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)\n                    };\n                    if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {\n                        this._chunkProcessor(this._chunkProcessorBuffer);\n                        this._chunkProcessorBuffer = {\n                            raw: new ArrayBuffer(0),\n                            mono: new ArrayBuffer(0)\n                        };\n                    }\n                } else this._chunkProcessor(data);\n            }\n        };\n        const node = source.connect(processor);\n        const analyser = context.createAnalyser();\n        analyser.fftSize = 8192;\n        analyser.smoothingTimeConstant = 0.1;\n        node.connect(analyser);\n        if (this.outputToSpeakers) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Warning: Output to speakers may affect sound quality,\\nespecially due to system audio feedback preventative measures.\\nuse only for debugging\");\n            analyser.connect(context.destination);\n        }\n        this.source = source;\n        this.node = node;\n        this.analyser = analyser;\n        this.processor = processor;\n        return true;\n    }\n    /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = \"frequency\", minDecibels = -100, maxDecibels = -30) {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */ async pause() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        else if (!this.recording) throw new Error(\"Already paused: please call .record() first\");\n        if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);\n        this.log(\"Pausing ...\");\n        await this._event(\"stop\");\n        this.recording = false;\n        return true;\n    }\n    /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */ async record(chunkProcessor = ()=>{}, chunkSize = 8192) {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        else if (this.recording) throw new Error(\"Already recording: HELLO please call .pause() first\");\n        else if (typeof chunkProcessor !== \"function\") throw new Error(`chunkProcessor must be a function`);\n        this._chunkProcessor = chunkProcessor;\n        this._chunkProcessorSize = chunkSize;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n        this.log(\"Recording ...\");\n        await this._event(\"start\");\n        this.recording = true;\n        return true;\n    }\n    /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */ async clear() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        await this._event(\"clear\");\n        return true;\n    }\n    /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */ async read() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        this.log(\"Reading ...\");\n        const result = await this._event(\"read\");\n        return result;\n    }\n    /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async save(force = false) {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        if (!force && this.recording) throw new Error(\"Currently recording: please call .pause() first, or call .save(true) to force\");\n        this.log(\"Exporting ...\");\n        const exportData = await this._event(\"export\");\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async end() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        const _processor = this.processor;\n        this.log(\"Stopping ...\");\n        await this._event(\"stop\");\n        this.recording = false;\n        this.log(\"Exporting ...\");\n        const exportData = await this._event(\"export\", {}, _processor);\n        this.processor.disconnect();\n        this.source.disconnect();\n        this.node.disconnect();\n        this.analyser.disconnect();\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */ async quit() {\n        this.listenForDeviceChange(null);\n        if (this.processor) await this.end();\n        return true;\n    }\n}\nglobalThis.WavRecorder = WavRecorder;\n\n\n\n\nvar $58d19ff082af5e5c$exports = {};\n$58d19ff082af5e5c$exports = JSON.parse(\"{\\\"name\\\":\\\"@pipecat-ai/daily-transport\\\",\\\"version\\\":\\\"1.4.0\\\",\\\"license\\\":\\\"BSD-2-Clause\\\",\\\"main\\\":\\\"dist/index.js\\\",\\\"module\\\":\\\"dist/index.module.js\\\",\\\"types\\\":\\\"dist/index.d.ts\\\",\\\"source\\\":\\\"src/index.ts\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/pipecat-ai/pipecat-client-web-transports.git\\\"},\\\"files\\\":[\\\"dist\\\",\\\"package.json\\\",\\\"README.md\\\"],\\\"scripts\\\":{\\\"build\\\":\\\"parcel build --no-cache\\\",\\\"dev\\\":\\\"parcel watch\\\",\\\"lint\\\":\\\"eslint . --ext ts --report-unused-disable-directives --max-warnings 0\\\"},\\\"devDependencies\\\":{\\\"@pipecat-ai/client-js\\\":\\\"^1.4.0\\\",\\\"eslint\\\":\\\"9.11.1\\\",\\\"eslint-config-prettier\\\":\\\"^9.1.0\\\",\\\"eslint-plugin-simple-import-sort\\\":\\\"^12.1.1\\\"},\\\"peerDependencies\\\":{\\\"@pipecat-ai/client-js\\\":\\\"~1.4.0\\\"},\\\"dependencies\\\":{\\\"@daily-co/daily-js\\\":\\\"^0.83.1\\\"},\\\"description\\\":\\\"Pipecat Daily Transport Package\\\",\\\"author\\\":\\\"Daily.co\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/pipecat-ai/pipecat-client-web-transports/issues\\\"},\\\"homepage\\\":\\\"https://github.com/pipecat-ai/pipecat-client-web-transports/blob/main/transports/daily-webrtc/README.md\\\"}\");\n\n\nvar $683f111f61e07358$export$ef180de88fd317cc;\n(function(DailyRTVIMessageType) {\n    DailyRTVIMessageType[\"AUDIO_BUFFERING_STARTED\"] = \"audio-buffering-started\";\n    DailyRTVIMessageType[\"AUDIO_BUFFERING_STOPPED\"] = \"audio-buffering-stopped\";\n})($683f111f61e07358$export$ef180de88fd317cc || ($683f111f61e07358$export$ef180de88fd317cc = {}));\nclass $683f111f61e07358$var$DailyCallWrapper {\n    constructor(daily){\n        this._daily = daily;\n        this._proxy = new Proxy(this._daily, {\n            get: (target, prop, receiver)=>{\n                if (typeof target[prop] === \"function\") {\n                    let errMsg;\n                    switch(String(prop)){\n                        // Disable methods that modify the lifecycle of the call. These operations\n                        // should be performed via the PipecatClient in order to keep state in sync.\n                        case \"preAuth\":\n                            errMsg = `Calls to preAuth() are disabled. Please use Transport.preAuth()`;\n                            break;\n                        case \"startCamera\":\n                            errMsg = `Calls to startCamera() are disabled. Please use PipecatClient.initDevices()`;\n                            break;\n                        case \"join\":\n                            errMsg = `Calls to join() are disabled. Please use PipecatClient.connect()`;\n                            break;\n                        case \"leave\":\n                            errMsg = `Calls to leave() are disabled. Please use PipecatClient.disconnect()`;\n                            break;\n                        case \"destroy\":\n                            errMsg = `Calls to destroy() are disabled.`;\n                            break;\n                    }\n                    if (errMsg) return ()=>{\n                        throw new Error(errMsg);\n                    };\n                    // Forward other method calls\n                    return (...args)=>{\n                        return target[prop](...args);\n                    };\n                }\n                // Forward property access\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    get proxy() {\n        return this._proxy;\n    }\n}\nclass $683f111f61e07358$export$b1ca982aa1e488c1 extends (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.Transport) {\n    constructor(opts = {}){\n        super();\n        this._botId = \"\";\n        this._selectedCam = {};\n        this._selectedMic = {};\n        this._selectedSpeaker = {};\n        this._currentAudioTrack = null;\n        this._audioQueue = [];\n        this._callbacks = {};\n        const { bufferLocalAudioUntilBotReady: bufferLocalAudioUntilBotReady, ...dailyOpts } = opts;\n        this._dailyFactoryOptions = dailyOpts;\n        // Enable device preference cookies by default\n        if (typeof this._dailyFactoryOptions.dailyConfig?.useDevicePreferenceCookies === \"undefined\") {\n            // purposeful == to check undefined or null\n            if (this._dailyFactoryOptions.dailyConfig == null) this._dailyFactoryOptions.dailyConfig = {};\n            this._dailyFactoryOptions.dailyConfig.useDevicePreferenceCookies = true;\n        }\n        this._bufferLocalAudioUntilBotReady = bufferLocalAudioUntilBotReady || false;\n        this._daily = (0, _daily_co_daily_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]).createCallObject({\n            ...this._dailyFactoryOptions,\n            allowMultipleCallInstances: true\n        });\n        this._dailyWrapper = new $683f111f61e07358$var$DailyCallWrapper(this._daily);\n    }\n    setupRecorder() {\n        this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a48)({\n            sampleRate: $683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE\n        });\n    }\n    handleUserAudioStream(data) {\n        this._audioQueue.push(data);\n    }\n    flushAudioQueue() {\n        const batchSize = 10; // Number of buffers to send in one message\n        if (this._audioQueue.length === 0) return;\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).debug(`Will flush audio queue: ${this._audioQueue.length}`);\n        while(this._audioQueue.length > 0){\n            const batch = [];\n            // Collect up to `batchSize` items\n            while(batch.length < batchSize && this._audioQueue.length > 0){\n                const queuedData = this._audioQueue.shift();\n                if (queuedData) batch.push(queuedData);\n            }\n            if (batch.length > 0) this._sendAudioBatch(batch);\n        }\n    }\n    _sendAudioBatch(dataBatch) {\n        const encodedBatch = dataBatch.map((data)=>{\n            const pcmByteArray = new Uint8Array(data);\n            return btoa(String.fromCharCode(...pcmByteArray));\n        });\n        const audioMessage = {\n            id: \"raw-audio-batch\",\n            label: \"rtvi-ai\",\n            type: \"raw-audio-batch\",\n            data: {\n                base64AudioBatch: encodedBatch,\n                sampleRate: $683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE,\n                numChannels: 1\n            }\n        };\n        this.sendMessage(audioMessage);\n    }\n    initialize(options, messageHandler) {\n        if (this._bufferLocalAudioUntilBotReady) this.setupRecorder();\n        this._callbacks = options.callbacks ?? {};\n        this._onMessage = messageHandler;\n        if (this._dailyFactoryOptions.startVideoOff == null || options.enableCam != null) // Default is cam off\n        this._dailyFactoryOptions.startVideoOff = !(options.enableCam ?? false);\n        if (this._dailyFactoryOptions.startAudioOff == null || options.enableMic != null) // Default is mic on\n        this._dailyFactoryOptions.startAudioOff = !(options.enableMic ?? true);\n        this.attachEventListeners();\n        this.state = \"disconnected\";\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).debug(\"[Daily Transport] Initialized\", (0, (/*@__PURE__*/$parcel$interopDefault($58d19ff082af5e5c$exports))).version);\n    }\n    get dailyCallClient() {\n        return this._dailyWrapper.proxy;\n    }\n    get state() {\n        return this._state;\n    }\n    set state(state) {\n        if (this._state === state) return;\n        this._state = state;\n        this._callbacks.onTransportStateChanged?.(state);\n    }\n    getSessionInfo() {\n        return this._daily.meetingSessionSummary();\n    }\n    async getAllCams() {\n        const { devices: devices } = await this._daily.enumerateDevices();\n        return devices.filter((d)=>d.kind === \"videoinput\");\n    }\n    updateCam(camId) {\n        this._daily.setInputDevicesAsync({\n            videoDeviceId: camId\n        }).then((infos)=>{\n            this._selectedCam = infos.camera;\n        });\n    }\n    get selectedCam() {\n        return this._selectedCam;\n    }\n    async getAllMics() {\n        const { devices: devices } = await this._daily.enumerateDevices();\n        return devices.filter((d)=>d.kind === \"audioinput\");\n    }\n    updateMic(micId) {\n        this._daily.setInputDevicesAsync({\n            audioDeviceId: micId\n        }).then((infos)=>{\n            this._selectedMic = infos.mic;\n        });\n    }\n    get selectedMic() {\n        return this._selectedMic;\n    }\n    async getAllSpeakers() {\n        const { devices: devices } = await this._daily.enumerateDevices();\n        return devices.filter((d)=>d.kind === \"audiooutput\");\n    }\n    updateSpeaker(speakerId) {\n        this._daily.setOutputDeviceAsync({\n            outputDeviceId: speakerId\n        }).then((infos)=>{\n            this._selectedSpeaker = infos.speaker;\n        }).catch((e)=>{\n            this._callbacks.onDeviceError?.(new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)([\n                \"speaker\"\n            ], e.type ?? \"unknown\", e.message));\n        });\n    }\n    get selectedSpeaker() {\n        return this._selectedSpeaker;\n    }\n    enableMic(enable) {\n        this._daily.setLocalAudio(enable);\n    }\n    get isMicEnabled() {\n        return this._daily.localAudio();\n    }\n    enableCam(enable) {\n        this._daily.setLocalVideo(enable);\n    }\n    get isCamEnabled() {\n        return this._daily.localVideo();\n    }\n    enableScreenShare(enable) {\n        if (enable) this._daily.startScreenShare();\n        else this._daily.stopScreenShare();\n    }\n    get isSharingScreen() {\n        return this._daily.localScreenAudio() || this._daily.localScreenVideo();\n    }\n    tracks() {\n        const participants = this._daily.participants() ?? {};\n        const bot = participants?.[this._botId];\n        const tracks = {\n            local: {\n                audio: participants?.local?.tracks?.audio?.persistentTrack,\n                screenAudio: participants?.local?.tracks?.screenAudio?.persistentTrack,\n                screenVideo: participants?.local?.tracks?.screenVideo?.persistentTrack,\n                video: participants?.local?.tracks?.video?.persistentTrack\n            }\n        };\n        if (bot) tracks.bot = {\n            audio: bot?.tracks?.audio?.persistentTrack,\n            video: bot?.tracks?.video?.persistentTrack\n        };\n        return tracks;\n    }\n    async startRecording() {\n        try {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).info(\"[Daily Transport] Initializing recording\");\n            await this._mediaStreamRecorder.record((data)=>{\n                this.handleUserAudioStream(data.mono);\n            }, $683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_CHUNK_SIZE);\n            this._callbacks.onAudioBufferingStarted?.();\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).info(\"[Daily Transport] Recording Initialized\");\n        } catch (e) {\n            const err = e;\n            if (!err.message.includes(\"Already recording\")) (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"Error starting recording\", e);\n        }\n    }\n    async preAuth(dailyCallOptions) {\n        this._dailyFactoryOptions = dailyCallOptions;\n        await this._daily.preAuth(dailyCallOptions);\n    }\n    async initDevices() {\n        if (!this._daily) throw new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.RTVIError)(\"Transport instance not initialized\");\n        this.state = \"initializing\";\n        const infos = await this._daily.startCamera(this._dailyFactoryOptions);\n        const { devices: devices } = await this._daily.enumerateDevices();\n        const cams = devices.filter((d)=>d.kind === \"videoinput\");\n        const mics = devices.filter((d)=>d.kind === \"audioinput\");\n        const speakers = devices.filter((d)=>d.kind === \"audiooutput\");\n        this._selectedCam = infos.camera;\n        this._selectedMic = infos.mic;\n        this._selectedSpeaker = infos.speaker;\n        this._callbacks.onAvailableCamsUpdated?.(cams);\n        this._callbacks.onAvailableMicsUpdated?.(mics);\n        this._callbacks.onAvailableSpeakersUpdated?.(speakers);\n        this._callbacks.onCamUpdated?.(infos.camera);\n        this._callbacks.onMicUpdated?.(infos.mic);\n        this._callbacks.onSpeakerUpdated?.(infos.speaker);\n        // Instantiate audio observers\n        if (!this._daily.isLocalAudioLevelObserverRunning()) await this._daily.startLocalAudioLevelObserver(100);\n        if (!this._daily.isRemoteParticipantsAudioLevelObserverRunning()) await this._daily.startRemoteParticipantsAudioLevelObserver(100);\n        this.state = \"initialized\";\n    }\n    _validateConnectionParams(connectParams) {\n        if (connectParams === undefined || connectParams === null) return undefined;\n        if (typeof connectParams !== \"object\") throw new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.RTVIError)(\"Invalid connection parameters\");\n        const tmpParams = connectParams;\n        if (tmpParams.room_url) {\n            tmpParams.url = tmpParams.room_url;\n            delete tmpParams.room_url;\n        } else if (tmpParams.dailyRoom) {\n            tmpParams.url = tmpParams.dailyRoom;\n            delete tmpParams.dailyRoom;\n        }\n        if (tmpParams.dailyToken) {\n            tmpParams.token = tmpParams.dailyToken;\n            delete tmpParams.dailyToken;\n        }\n        if (!tmpParams.token) // Daily doesn't like token being in the map and undefined or null\n        delete tmpParams.token;\n        return tmpParams;\n    }\n    async _connect(connectParams) {\n        if (!this._daily) throw new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.RTVIError)(\"Transport instance not initialized\");\n        if (connectParams) this._dailyFactoryOptions = {\n            ...this._dailyFactoryOptions,\n            ...connectParams\n        };\n        this.state = \"connecting\";\n        try {\n            await this._daily.join(this._dailyFactoryOptions);\n        } catch (e) {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"Failed to join room\", e);\n            this.state = \"error\";\n            throw new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.TransportStartError)();\n        }\n        if (this._abortController?.signal.aborted) return;\n        this.state = \"connected\";\n        this._callbacks.onConnected?.();\n    }\n    async sendReadyMessage() {\n        return new Promise((resolve)=>{\n            // Detect iOS devices\n            const isIOS = ()=>{\n                const userAgent = navigator.userAgent;\n                return /iPad|iPhone|iPod/.test(userAgent) || /Macintosh/.test(userAgent) && \"ontouchend\" in document;\n            };\n            const sendReadyMessage = ()=>{\n                // TODO: Consider changing to match the iOS/Android SDKs where\n                //       we don't actually set our state to \"ready\" until\n                //       we've received the bot_ready signal\n                this.state = \"ready\";\n                this.flushAudioQueue();\n                this.sendMessage((0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.RTVIMessage).clientReady());\n                this.stopRecording();\n                resolve();\n            };\n            for(const id in this._daily.participants()){\n                const p = this._daily.participants()[id];\n                if (!p.local && p.tracks?.audio?.persistentTrack) {\n                    // If we already have a remote audio track, we can send the ready message immediately\n                    sendReadyMessage();\n                    resolve();\n                    return;\n                }\n            }\n            const readyHandler = (ev)=>{\n                if (!ev.participant?.local) {\n                    this._daily.off(\"track-started\", readyHandler);\n                    // Check if it's an iOS device\n                    if (isIOS()) {\n                        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).debug(\"[Daily Transport] iOS device detected, adding 0.5 second delay before sending ready message\");\n                        // Add 500ms delay for iOS devices:\n                        // This is a workaround for iOS devices clipping a portion\n                        // of the audio after the track becomes playable.\n                        setTimeout(sendReadyMessage, 500);\n                    } else // Non-iOS device, send ready message immediately\n                    sendReadyMessage();\n                }\n            };\n            this._daily.on(\"track-started\", readyHandler);\n        });\n    }\n    stopRecording() {\n        if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() !== \"ended\") {\n            // disconnecting, we don't need to record anymore\n            this._mediaStreamRecorder.end();\n            this._callbacks.onAudioBufferingStopped?.();\n        }\n    }\n    attachEventListeners() {\n        this._daily.on(\"available-devices-updated\", this.handleAvailableDevicesUpdated.bind(this));\n        this._daily.on(\"selected-devices-updated\", this.handleSelectedDevicesUpdated.bind(this));\n        this._daily.on(\"camera-error\", this.handleDeviceError.bind(this));\n        this._daily.on(\"track-started\", this.handleTrackStarted.bind(this));\n        this._daily.on(\"track-stopped\", this.handleTrackStopped.bind(this));\n        this._daily.on(\"participant-joined\", this.handleParticipantJoined.bind(this));\n        this._daily.on(\"participant-left\", this.handleParticipantLeft.bind(this));\n        this._daily.on(\"local-audio-level\", this.handleLocalAudioLevel.bind(this));\n        this._daily.on(\"remote-participants-audio-level\", this.handleRemoteAudioLevel.bind(this));\n        this._daily.on(\"app-message\", this.handleAppMessage.bind(this));\n        this._daily.on(\"left-meeting\", this.handleLeftMeeting.bind(this));\n        this._daily.on(\"error\", this.handleFatalError.bind(this));\n        this._daily.on(\"nonfatal-error\", this.handleNonFatalError.bind(this));\n    }\n    async _disconnect() {\n        this.state = \"disconnecting\";\n        this._daily.stopLocalAudioLevelObserver();\n        this._daily.stopRemoteParticipantsAudioLevelObserver();\n        this._audioQueue = [];\n        this._currentAudioTrack = null;\n        this.stopRecording();\n        await this._daily.leave();\n    }\n    sendMessage(message) {\n        this._daily.sendAppMessage(message, \"*\");\n    }\n    handleAppMessage(ev) {\n        // Bubble any messages with rtvi-ai label\n        if (ev.data.label === \"rtvi-ai\") this._onMessage({\n            id: ev.data.id,\n            type: ev.data.type,\n            data: ev.data.data\n        });\n    }\n    handleAvailableDevicesUpdated(ev) {\n        this._callbacks.onAvailableCamsUpdated?.(ev.availableDevices.filter((d)=>d.kind === \"videoinput\"));\n        this._callbacks.onAvailableMicsUpdated?.(ev.availableDevices.filter((d)=>d.kind === \"audioinput\"));\n        this._callbacks.onAvailableSpeakersUpdated?.(ev.availableDevices.filter((d)=>d.kind === \"audiooutput\"));\n    }\n    handleSelectedDevicesUpdated(ev) {\n        if (this._selectedCam?.deviceId !== ev.devices.camera) {\n            this._selectedCam = ev.devices.camera;\n            this._callbacks.onCamUpdated?.(ev.devices.camera);\n        }\n        if (this._selectedMic?.deviceId !== ev.devices.mic) {\n            this._selectedMic = ev.devices.mic;\n            this._callbacks.onMicUpdated?.(ev.devices.mic);\n        }\n        if (this._selectedSpeaker?.deviceId !== ev.devices.speaker) {\n            this._selectedSpeaker = ev.devices.speaker;\n            this._callbacks.onSpeakerUpdated?.(ev.devices.speaker);\n        }\n    }\n    handleDeviceError(ev) {\n        const generateDeviceError = (error)=>{\n            const devices = [];\n            switch(error.type){\n                case \"permissions\":\n                    error.blockedMedia.forEach((d)=>{\n                        devices.push(d === \"video\" ? \"cam\" : \"mic\");\n                    });\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, error.type, error.msg, {\n                        blockedBy: error.blockedBy\n                    });\n                case \"not-found\":\n                    error.missingMedia.forEach((d)=>{\n                        devices.push(d === \"video\" ? \"cam\" : \"mic\");\n                    });\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, error.type, error.msg);\n                case \"constraints\":\n                    error.failedMedia.forEach((d)=>{\n                        devices.push(d === \"video\" ? \"cam\" : \"mic\");\n                    });\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, error.type, error.msg, {\n                        reason: error.reason\n                    });\n                case \"cam-in-use\":\n                    devices.push(\"cam\");\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, \"in-use\", error.msg);\n                case \"mic-in-use\":\n                    devices.push(\"mic\");\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, \"in-use\", error.msg);\n                case \"cam-mic-in-use\":\n                    devices.push(\"cam\");\n                    devices.push(\"mic\");\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, \"in-use\", error.msg);\n                case \"undefined-mediadevices\":\n                case \"unknown\":\n                default:\n                    devices.push(\"cam\");\n                    devices.push(\"mic\");\n                    return new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.DeviceError)(devices, error.type, error.msg);\n            }\n        };\n        this._callbacks.onDeviceError?.(generateDeviceError(ev.error));\n    }\n    async handleLocalAudioTrack(track) {\n        if (this.state == \"ready\" || !this._bufferLocalAudioUntilBotReady) return;\n        const status = this._mediaStreamRecorder.getStatus();\n        switch(status){\n            case \"ended\":\n                try {\n                    await this._mediaStreamRecorder.begin(track);\n                    await this.startRecording();\n                } catch (e) {\n                // void. nothing to do.\n                }\n                break;\n            case \"paused\":\n                await this.startRecording();\n                break;\n            case \"recording\":\n            default:\n                if (this._currentAudioTrack !== track) try {\n                    await this._mediaStreamRecorder.end();\n                    await this._mediaStreamRecorder.begin(track);\n                    await this.startRecording();\n                } catch (e) {\n                // void. nothing to do.\n                }\n                else (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).warn(\"track-started event received for current track and already recording\");\n                break;\n        }\n        this._currentAudioTrack = track;\n    }\n    handleTrackStarted(ev) {\n        if (ev.type === \"screenAudio\" || ev.type === \"screenVideo\") this._callbacks.onScreenTrackStarted?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : undefined);\n        else {\n            if (ev.participant?.local && ev.track.kind === \"audio\") this.handleLocalAudioTrack(ev.track);\n            this._callbacks.onTrackStarted?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : undefined);\n        }\n    }\n    handleTrackStopped(ev) {\n        if (ev.type === \"screenAudio\" || ev.type === \"screenVideo\") this._callbacks.onScreenTrackStopped?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : undefined);\n        else this._callbacks.onTrackStopped?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : undefined);\n    }\n    handleParticipantJoined(ev) {\n        const p = $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant);\n        this._callbacks.onParticipantJoined?.(p);\n        if (p.local) return;\n        this._botId = ev.participant.session_id;\n        this._callbacks.onBotConnected?.(p);\n    }\n    handleParticipantLeft(ev) {\n        const p = $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant);\n        this._callbacks.onParticipantLeft?.(p);\n        if (p.local) return;\n        this._botId = \"\";\n        this._callbacks.onBotDisconnected?.(p);\n    }\n    handleLocalAudioLevel(ev) {\n        this._callbacks.onLocalAudioLevel?.(ev.audioLevel);\n    }\n    handleRemoteAudioLevel(ev) {\n        const participants = this._daily.participants();\n        const ids = Object.keys(ev.participantsAudioLevel);\n        for(let i = 0; i < ids.length; i++){\n            const id = ids[i];\n            const level = ev.participantsAudioLevel[id];\n            this._callbacks.onRemoteAudioLevel?.(level, $683f111f61e07358$var$dailyParticipantToParticipant(participants[id]));\n        }\n    }\n    handleLeftMeeting() {\n        this.state = \"disconnected\";\n        this._botId = \"\";\n        this._callbacks.onDisconnected?.();\n    }\n    handleFatalError(ev) {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"Daily fatal error\", ev.errorMsg);\n        this.state = \"error\";\n        this._botId = \"\";\n        this._callbacks.onError?.((0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.RTVIMessage).error(ev.errorMsg, true));\n    }\n    handleNonFatalError(ev) {\n        switch(ev.type){\n            case \"screen-share-error\":\n                this._callbacks.onScreenShareError?.(ev.errorMsg);\n                break;\n        }\n    }\n}\n$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE = 16000;\n$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_CHUNK_SIZE = 512;\nconst $683f111f61e07358$var$dailyParticipantToParticipant = (p)=>({\n        id: p.user_id,\n        local: p.local,\n        name: p.user_name\n    });\n\n\n\n\n\n//# sourceMappingURL=index.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBpcGVjYXQtYWkrZGFpbHktdHJhbnNwb3J0QDEuNC4xX0BwaXBlY2F0LWFpK2NsaWVudC1qc0AxLjQuMS9ub2RlX21vZHVsZXMvQHBpcGVjYXQtYWkvZGFpbHktdHJhbnNwb3J0L2Rpc3QvaW5kZXgubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDOEw7OztBQUdyUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IscURBQXFEO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMseUVBQXlFO0FBQ3ZGLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBK0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBYTtBQUN6QjtBQUNBO0FBQ0Esc0NBQXNDLDhEQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7OztBQUttSTtBQUN4SSIsInNvdXJjZXMiOlsiL1VzZXJzL2ppYXdlbnpodS9EZXZlbG9wZXIvSmFzdGFsa192YXBpL2NsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQHBpcGVjYXQtYWkrZGFpbHktdHJhbnNwb3J0QDEuNC4xX0BwaXBlY2F0LWFpK2NsaWVudC1qc0AxLjQuMS9ub2RlX21vZHVsZXMvQHBpcGVjYXQtYWkvZGFpbHktdHJhbnNwb3J0L2Rpc3QvaW5kZXgubW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkN3piRDgkZGFpbHljb2RhaWx5anMgZnJvbSBcIkBkYWlseS1jby9kYWlseS1qc1wiO1xuaW1wb3J0IHtsb2dnZXIgYXMgJDd6YkQ4JGxvZ2dlciwgRGV2aWNlRXJyb3IgYXMgJDd6YkQ4JERldmljZUVycm9yLCBSVFZJRXJyb3IgYXMgJDd6YkQ4JFJUVklFcnJvciwgVHJhbnNwb3J0U3RhcnRFcnJvciBhcyAkN3piRDgkVHJhbnNwb3J0U3RhcnRFcnJvciwgUlRWSU1lc3NhZ2UgYXMgJDd6YkQ4JFJUVklNZXNzYWdlLCBUcmFuc3BvcnQgYXMgJDd6YkQ4JFRyYW5zcG9ydH0gZnJvbSBcIkBwaXBlY2F0LWFpL2NsaWVudC1qc1wiO1xuXG5cbmZ1bmN0aW9uICRwYXJjZWwkaW50ZXJvcERlZmF1bHQoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhLmRlZmF1bHQgOiBhO1xufVxuXG5mdW5jdGlvbiAkcGFyY2VsJGV4cG9ydChlLCBuLCB2LCBzKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBuLCB7Z2V0OiB2LCBzZXQ6IHMsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xufVxudmFyICQ2ODNmMTExZjYxZTA3MzU4JGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDY4M2YxMTFmNjFlMDczNTgkZXhwb3J0cywgXCJEYWlseVJUVklNZXNzYWdlVHlwZVwiLCAoKSA9PiAkNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkZWYxODBkZTg4ZmQzMTdjYyk7XG4kcGFyY2VsJGV4cG9ydCgkNjgzZjExMWY2MWUwNzM1OCRleHBvcnRzLCBcIkRhaWx5VHJhbnNwb3J0XCIsICgpID0+ICQ2ODNmMTExZjYxZTA3MzU4JGV4cG9ydCRiMWNhOTgyYWExZTQ4OGMxKTtcblxuXG4vKipcbiAqIFJhdyB3YXYgYXVkaW8gZmlsZSBjb250ZW50c1xuICogQHR5cGVkZWYge09iamVjdH0gV2F2UGFja2VyQXVkaW9UeXBlXG4gKiBAcHJvcGVydHkge0Jsb2J9IGJsb2JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFubmVsQ291bnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYW1wbGVSYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqLyAvKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIGFzc2VtYmxpbmcgUENNMTYgXCJhdWRpby93YXZcIiBkYXRhXG4gKiBAY2xhc3NcbiAqLyBjbGFzcyAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NiB7XG4gICAgLyoqXG4gICAqIENvbnZlcnRzIEZsb2F0MzJBcnJheSBvZiBhbXBsaXR1ZGUgZGF0YSB0byBBcnJheUJ1ZmZlciBpbiBJbnQxNkFycmF5IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZmxvYXQzMkFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovIHN0YXRpYyBmbG9hdFRvMTZCaXRQQ00oZmxvYXQzMkFycmF5KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmbG9hdDMyQXJyYXkubGVuZ3RoICogMik7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmbG9hdDMyQXJyYXkubGVuZ3RoOyBpKyssIG9mZnNldCArPSAyKXtcbiAgICAgICAgICAgIGxldCBzID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGZsb2F0MzJBcnJheVtpXSkpO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQsIHMgPCAwID8gcyAqIDB4ODAwMCA6IHMgKiAweDdmZmYsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgdHdvIEFycmF5QnVmZmVyc1xuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBsZWZ0QnVmZmVyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IHJpZ2h0QnVmZmVyXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovIHN0YXRpYyBtZXJnZUJ1ZmZlcnMobGVmdEJ1ZmZlciwgcmlnaHRCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgdG1wQXJyYXkgPSBuZXcgVWludDhBcnJheShsZWZ0QnVmZmVyLmJ5dGVMZW5ndGggKyByaWdodEJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wQXJyYXkuc2V0KG5ldyBVaW50OEFycmF5KGxlZnRCdWZmZXIpLCAwKTtcbiAgICAgICAgdG1wQXJyYXkuc2V0KG5ldyBVaW50OEFycmF5KHJpZ2h0QnVmZmVyKSwgbGVmdEJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRtcEFycmF5LmJ1ZmZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBhY2tzIGRhdGEgaW50byBhbiBJbnQxNiBmb3JtYXRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgMCA9IDF4IEludDE2LCAxID0gMnggSW50MTZcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFyZyB2YWx1ZSB0byBwYWNrXG4gICAqIEByZXR1cm5zXG4gICAqLyBfcGFja0RhdGEoc2l6ZSwgYXJnKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGFyZyA+PiA4XG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgYXJnID4+IDgsXG4gICAgICAgICAgICAgICAgYXJnID4+IDE2LFxuICAgICAgICAgICAgICAgIGFyZyA+PiAyNFxuICAgICAgICAgICAgXSlcbiAgICAgICAgXVtzaXplXTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBhY2tzIGF1ZGlvIGludG8gXCJhdWRpby93YXZcIiBCbG9iXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRlXG4gICAqIEBwYXJhbSB7e2JpdHNQZXJTYW1wbGU6IG51bWJlciwgY2hhbm5lbHM6IEFycmF5PEZsb2F0MzJBcnJheT4sIGRhdGE6IEludDE2QXJyYXl9fSBhdWRpb1xuICAgKiBAcmV0dXJucyB7V2F2UGFja2VyQXVkaW9UeXBlfVxuICAgKi8gcGFjayhzYW1wbGVSYXRlLCBhdWRpbykge1xuICAgICAgICBpZiAoIWF1ZGlvPy5iaXRzUGVyU2FtcGxlKSB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgXCJiaXRzUGVyU2FtcGxlXCJgKTtcbiAgICAgICAgZWxzZSBpZiAoIWF1ZGlvPy5jaGFubmVscykgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIFwiY2hhbm5lbHNcImApO1xuICAgICAgICBlbHNlIGlmICghYXVkaW8/LmRhdGEpIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBcImRhdGFcImApO1xuICAgICAgICBjb25zdCB7IGJpdHNQZXJTYW1wbGU6IGJpdHNQZXJTYW1wbGUsIGNoYW5uZWxzOiBjaGFubmVscywgZGF0YTogZGF0YSB9ID0gYXVkaW87XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtcbiAgICAgICAgICAgIC8vIEhlYWRlclxuICAgICAgICAgICAgJ1JJRkYnLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMSwgNTIpLFxuICAgICAgICAgICAgJ1dBVkUnLFxuICAgICAgICAgICAgLy8gY2h1bmsgMVxuICAgICAgICAgICAgJ2ZtdCAnLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMSwgMTYpLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMCwgMSksXG4gICAgICAgICAgICB0aGlzLl9wYWNrRGF0YSgwLCBjaGFubmVscy5sZW5ndGgpLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMSwgc2FtcGxlUmF0ZSksXG4gICAgICAgICAgICB0aGlzLl9wYWNrRGF0YSgxLCBzYW1wbGVSYXRlICogY2hhbm5lbHMubGVuZ3RoICogYml0c1BlclNhbXBsZSAvIDgpLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMCwgY2hhbm5lbHMubGVuZ3RoICogYml0c1BlclNhbXBsZSAvIDgpLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMCwgYml0c1BlclNhbXBsZSksXG4gICAgICAgICAgICAvLyBjaHVuayAyXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICB0aGlzLl9wYWNrRGF0YSgxLCBjaGFubmVsc1swXS5sZW5ndGggKiBjaGFubmVscy5sZW5ndGggKiBiaXRzUGVyU2FtcGxlIC8gOCksXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihvdXRwdXQsIHtcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpby9tcGVnJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogY2hhbm5lbHMubGVuZ3RoLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkYXRhLmJ5dGVMZW5ndGggLyAoY2hhbm5lbHMubGVuZ3RoICogc2FtcGxlUmF0ZSAqIDIpXG4gICAgICAgIH07XG4gICAgfVxufVxuZ2xvYmFsVGhpcy5XYXZQYWNrZXIgPSAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NjtcblxuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgaGVscCB3aXRoIHZpc3VhbGl6YXRpb25cbiAqIEhlbHBzIG1hcCBmcmVxdWVuY3kgcmFuZ2VzIGZyb20gRmFzdCBGb3VyaWVyIFRyYW5zZm9ybVxuICogdG8gaHVtYW4taW50ZXJwcmV0YWJsZSByYW5nZXMsIG5vdGFibHkgbXVzaWMgcmFuZ2VzIGFuZFxuICogaHVtYW4gdm9jYWwgcmFuZ2VzLlxuICovIC8vIEVpZ2h0aCBvY3RhdmUgZnJlcXVlbmNpZXNcbmNvbnN0ICQwM2Y3MWNlODVlMDBhZGE2JHZhciRvY3RhdmU4RnJlcXVlbmNpZXMgPSBbXG4gICAgNDE4Ni4wMSxcbiAgICA0NDM0LjkyLFxuICAgIDQ2OTguNjMsXG4gICAgNDk3OC4wMyxcbiAgICA1Mjc0LjA0LFxuICAgIDU1ODcuNjUsXG4gICAgNTkxOS45MSxcbiAgICA2MjcxLjkzLFxuICAgIDY2NDQuODgsXG4gICAgNzA0MC4wLFxuICAgIDc0NTguNjIsXG4gICAgNzkwMi4xM1xuXTtcbi8vIExhYmVscyBmb3IgZWFjaCBvZiB0aGUgYWJvdmUgZnJlcXVlbmNpZXNcbmNvbnN0ICQwM2Y3MWNlODVlMDBhZGE2JHZhciRvY3RhdmU4RnJlcXVlbmN5TGFiZWxzID0gW1xuICAgICdDJyxcbiAgICAnQyMnLFxuICAgICdEJyxcbiAgICAnRCMnLFxuICAgICdFJyxcbiAgICAnRicsXG4gICAgJ0YjJyxcbiAgICAnRycsXG4gICAgJ0cjJyxcbiAgICAnQScsXG4gICAgJ0EjJyxcbiAgICAnQidcbl07XG5jb25zdCAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNiA9IFtdO1xuY29uc3QgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JGZhY2QxNjdjYzI3ZWE5YjAgPSBbXTtcbmZvcihsZXQgaSA9IDE7IGkgPD0gODsgaSsrKWZvcihsZXQgZiA9IDA7IGYgPCAkMDNmNzFjZTg1ZTAwYWRhNiR2YXIkb2N0YXZlOEZyZXF1ZW5jaWVzLmxlbmd0aDsgZisrKXtcbiAgICBjb25zdCBmcmVxID0gJDAzZjcxY2U4NWUwMGFkYTYkdmFyJG9jdGF2ZThGcmVxdWVuY2llc1tmXTtcbiAgICAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNi5wdXNoKGZyZXEgLyBNYXRoLnBvdygyLCA4IC0gaSkpO1xuICAgICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCRmYWNkMTY3Y2MyN2VhOWIwLnB1c2goJDAzZjcxY2U4NWUwMGFkYTYkdmFyJG9jdGF2ZThGcmVxdWVuY3lMYWJlbHNbZl0gKyBpKTtcbn1cbi8qKlxuICogU3Vic2V0IG9mIHRoZSBub3RlIGZyZXF1ZW5jaWVzIGJldHdlZW4gMzIgYW5kIDIwMDAgSHpcbiAqIDYgb2N0YXZlIHJhbmdlOiBDMSB0byBCNlxuICovIGNvbnN0ICQwM2Y3MWNlODVlMDBhZGE2JHZhciR2b2ljZUZyZXF1ZW5jeVJhbmdlID0gW1xuICAgIDMyLjAsXG4gICAgMjAwMC4wXG5dO1xuY29uc3QgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JGRiYzE1ODFlZDJjZmExODMgPSAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNi5maWx0ZXIoKF8sIGkpPT57XG4gICAgcmV0dXJuICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCQ3NzZjNjM4OThhZTViNjM2W2ldID4gJDAzZjcxY2U4NWUwMGFkYTYkdmFyJHZvaWNlRnJlcXVlbmN5UmFuZ2VbMF0gJiYgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzZbaV0gPCAkMDNmNzFjZTg1ZTAwYWRhNiR2YXIkdm9pY2VGcmVxdWVuY3lSYW5nZVsxXTtcbn0pO1xuY29uc3QgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDMwYTZmMjg4MTMxMTA4OGYgPSAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkZmFjZDE2N2NjMjdlYTliMC5maWx0ZXIoKF8sIGkpPT57XG4gICAgcmV0dXJuICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCQ3NzZjNjM4OThhZTViNjM2W2ldID4gJDAzZjcxY2U4NWUwMGFkYTYkdmFyJHZvaWNlRnJlcXVlbmN5UmFuZ2VbMF0gJiYgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzZbaV0gPCAkMDNmNzFjZTg1ZTAwYWRhNiR2YXIkdm9pY2VGcmVxdWVuY3lSYW5nZVsxXTtcbn0pO1xuXG5cbmNsYXNzICRmMzJmMDY0NTY0ZWU2MmY2JGV4cG9ydCQyYzMxMzZkYTBiZjEzMGY5IHtcbiAgICAvKipcbiAgICogUmV0cmlldmVzIGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIGFuIEFuYWx5c2VyTm9kZSBhZGp1c3RlZCB0byBhIGRlY2liZWwgcmFuZ2VcbiAgICogcmV0dXJucyBodW1hbi1yZWFkYWJsZSBmb3JtYXR0aW5nIGFuZCBsYWJlbHNcbiAgICogQHBhcmFtIHtBbmFseXNlck5vZGV9IGFuYWx5c2VyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRlXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbZmZ0UmVzdWx0XVxuICAgKiBAcGFyYW0ge1wiZnJlcXVlbmN5XCJ8XCJtdXNpY1wifFwidm9pY2VcIn0gW2FuYWx5c2lzVHlwZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW5EZWNpYmVsc10gZGVmYXVsdCAtMTAwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RGVjaWJlbHNdIGRlZmF1bHQgLTMwXG4gICAqIEByZXR1cm5zIHtBdWRpb0FuYWx5c2lzT3V0cHV0VHlwZX1cbiAgICovIHN0YXRpYyBnZXRGcmVxdWVuY2llcyhhbmFseXNlciwgc2FtcGxlUmF0ZSwgZmZ0UmVzdWx0LCBhbmFseXNpc1R5cGUgPSAnZnJlcXVlbmN5JywgbWluRGVjaWJlbHMgPSAtMTAwLCBtYXhEZWNpYmVscyA9IC0zMCkge1xuICAgICAgICBpZiAoIWZmdFJlc3VsdCkge1xuICAgICAgICAgICAgZmZ0UmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgICAgICAgICBhbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoZmZ0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBueXF1aXN0RnJlcXVlbmN5ID0gc2FtcGxlUmF0ZSAvIDI7XG4gICAgICAgIGNvbnN0IGZyZXF1ZW5jeVN0ZXAgPSAxIC8gZmZ0UmVzdWx0Lmxlbmd0aCAqIG55cXVpc3RGcmVxdWVuY3k7XG4gICAgICAgIGxldCBvdXRwdXRWYWx1ZXM7XG4gICAgICAgIGxldCBmcmVxdWVuY2llcztcbiAgICAgICAgbGV0IGxhYmVscztcbiAgICAgICAgaWYgKGFuYWx5c2lzVHlwZSA9PT0gJ211c2ljJyB8fCBhbmFseXNpc1R5cGUgPT09ICd2b2ljZScpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZUZyZXF1ZW5jaWVzID0gYW5hbHlzaXNUeXBlID09PSAndm9pY2UnID8gKDAsICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCRkYmMxNTgxZWQyY2ZhMTgzKSA6ICgwLCAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNik7XG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGVPdXRwdXQgPSBBcnJheSh1c2VGcmVxdWVuY2llcy5sZW5ndGgpLmZpbGwobWluRGVjaWJlbHMpO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGZmdFJlc3VsdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlcXVlbmN5ID0gaSAqIGZyZXF1ZW5jeVN0ZXA7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1wbGl0dWRlID0gZmZ0UmVzdWx0W2ldO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgbiA9IHVzZUZyZXF1ZW5jaWVzLmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKWlmIChmcmVxdWVuY3kgPiB1c2VGcmVxdWVuY2llc1tuXSkge1xuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVPdXRwdXRbbl0gPSBNYXRoLm1heChhZ2dyZWdhdGVPdXRwdXRbbl0sIGFtcGxpdHVkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFZhbHVlcyA9IGFnZ3JlZ2F0ZU91dHB1dDtcbiAgICAgICAgICAgIGZyZXF1ZW5jaWVzID0gYW5hbHlzaXNUeXBlID09PSAndm9pY2UnID8gKDAsICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCRkYmMxNTgxZWQyY2ZhMTgzKSA6ICgwLCAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNik7XG4gICAgICAgICAgICBsYWJlbHMgPSBhbmFseXNpc1R5cGUgPT09ICd2b2ljZScgPyAoMCwgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDMwYTZmMjg4MTMxMTA4OGYpIDogKDAsICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCRmYWNkMTY3Y2MyN2VhOWIwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFZhbHVlcyA9IEFycmF5LmZyb20oZmZ0UmVzdWx0KTtcbiAgICAgICAgICAgIGZyZXF1ZW5jaWVzID0gb3V0cHV0VmFsdWVzLm1hcCgoXywgaSk9PmZyZXF1ZW5jeVN0ZXAgKiBpKTtcbiAgICAgICAgICAgIGxhYmVscyA9IGZyZXF1ZW5jaWVzLm1hcCgoZik9PmAke2YudG9GaXhlZCgyKX0gSHpgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBub3JtYWxpemUgdG8gezAsIDF9XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRPdXRwdXQgPSBvdXRwdXRWYWx1ZXMubWFwKCh2KT0+e1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKCh2IC0gbWluRGVjaWJlbHMpIC8gKG1heERlY2liZWxzIC0gbWluRGVjaWJlbHMpLCAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbGl6ZWRPdXRwdXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICBmcmVxdWVuY2llczogZnJlcXVlbmNpZXMsXG4gICAgICAgICAgICBsYWJlbHM6IGxhYmVsc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBdWRpb0FuYWx5c2lzIGluc3RhbmNlIGZvciBhbiBIVE1MQXVkaW9FbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEF1ZGlvRWxlbWVudH0gYXVkaW9FbGVtZW50XG4gICAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ8bnVsbH0gW2F1ZGlvQnVmZmVyXSBJZiBwcm92aWRlZCwgd2lsbCBjYWNoZSBhbGwgZnJlcXVlbmN5IGRvbWFpbiBkYXRhIGZyb20gdGhlIGJ1ZmZlclxuICAgKiBAcmV0dXJucyB7QXVkaW9BbmFseXNpc31cbiAgICovIGNvbnN0cnVjdG9yKGF1ZGlvRWxlbWVudCwgYXVkaW9CdWZmZXIgPSBudWxsKXtcbiAgICAgICAgdGhpcy5mZnRSZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhdWRpb0J1ZmZlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBNb2RpZmllZCBmcm9tXG4gICAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NTA2MzcxNS91c2luZy10aGUtd2ViLWF1ZGlvLWFwaS10by1hbmFseXplLWEtc29uZy13aXRob3V0LXBsYXlpbmdcbiAgICAgICAqXG4gICAgICAgKiBXZSBkbyB0aGlzIHRvIHBvcHVsYXRlIEZGVCB2YWx1ZXMgZm9yIHRoZSBhdWRpbyBpZiBwcm92aWRlZCBhbiBgYXVkaW9CdWZmZXJgXG4gICAgICAgKiBUaGUgcmVhc29uIHRvIGRvIHRoaXMgaXMgdGhhdCBTYWZhcmkgZmFpbHMgd2hlbiB1c2luZyBgY3JlYXRlTWVkaWFFbGVtZW50U291cmNlYFxuICAgICAgICogVGhpcyBoYXMgYSBub24temVybyBSQU0gY29zdCBzbyB3ZSBvbmx5IG9wdC1pbiB0byBydW4gaXQgb24gU2FmYXJpLCBDaHJvbWUgaXMgYmV0dGVyXG4gICAgICAgKi8gY29uc3QgeyBsZW5ndGg6IGxlbmd0aCwgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSB9ID0gYXVkaW9CdWZmZXI7XG4gICAgICAgICAgICBjb25zdCBvZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IE9mZmxpbmVBdWRpb0NvbnRleHQoe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gb2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5c2VyID0gb2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDgxOTI7XG4gICAgICAgICAgICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSAwLjE7XG4gICAgICAgICAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gICAgICAgICAgICAvLyBsaW1pdCBpcyA6OiAxMjggLyBzYW1wbGVSYXRlO1xuICAgICAgICAgICAgLy8gYnV0IHdlIGp1c3Qgd2FudCA2MGZwcyAtIGN1dHMgfjFzIGZyb20gNk1CIHRvIDFNQiBvZiBSQU1cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclF1YW50dW1JblNlY29uZHMgPSAxIC8gNjA7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbkluU2Vjb25kcyA9IGxlbmd0aCAvIHNhbXBsZVJhdGU7XG4gICAgICAgICAgICBjb25zdCBhbmFseXplID0gKGluZGV4KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1c3BlbmRUaW1lID0gcmVuZGVyUXVhbnR1bUluU2Vjb25kcyAqIGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kVGltZSA8IGR1cmF0aW9uSW5TZWNvbmRzKSBvZmZsaW5lQXVkaW9Db250ZXh0LnN1c3BlbmQoc3VzcGVuZFRpbWUpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmZ0UmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGFuYWx5c2VyLmdldEZsb2F0RnJlcXVlbmN5RGF0YShmZnRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZmdFJlc3VsdHMucHVzaChmZnRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBhbmFseXplKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKSBvZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgICAgICAgICAgZWxzZSBvZmZsaW5lQXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNvdXJjZS5zdGFydCgwKTtcbiAgICAgICAgICAgIGFuYWx5emUoMSk7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvID0gYXVkaW9FbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gb2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuYW5hbHlzZXIgPSBhbmFseXNlcjtcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCB0cmFjayA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoYXVkaW9FbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgICAgICBhbmFseXNlci5mZnRTaXplID0gODE5MjtcbiAgICAgICAgICAgIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IDAuMTtcbiAgICAgICAgICAgIHRyYWNrLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgICAgICAgICAgYW5hbHlzZXIuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5hdWRpbyA9IGF1ZGlvRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuYW5hbHlzZXIgPSBhbmFseXNlcjtcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlUmF0ZSA9IHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgZnJlcXVlbmN5IGRvbWFpbiBkYXRhIGZyb20gdGhlIHBsYXlpbmcgYXVkaW8gdHJhY2tcbiAgICogQHBhcmFtIHtcImZyZXF1ZW5jeVwifFwibXVzaWNcInxcInZvaWNlXCJ9IFthbmFseXNpc1R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRGVjaWJlbHNdIGRlZmF1bHQgLTEwMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heERlY2liZWxzXSBkZWZhdWx0IC0zMFxuICAgKiBAcmV0dXJucyB7QXVkaW9BbmFseXNpc091dHB1dFR5cGV9XG4gICAqLyBnZXRGcmVxdWVuY2llcyhhbmFseXNpc1R5cGUgPSAnZnJlcXVlbmN5JywgbWluRGVjaWJlbHMgPSAtMTAwLCBtYXhEZWNpYmVscyA9IC0zMCkge1xuICAgICAgICBsZXQgZmZ0UmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9CdWZmZXIgJiYgdGhpcy5mZnRSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5hdWRpby5jdXJyZW50VGltZSAvIHRoaXMuYXVkaW8uZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IE1hdGgubWluKHBjdCAqIHRoaXMuZmZ0UmVzdWx0cy5sZW5ndGggfCAwLCB0aGlzLmZmdFJlc3VsdHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBmZnRSZXN1bHQgPSB0aGlzLmZmdFJlc3VsdHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkZjMyZjA2NDU2NGVlNjJmNiRleHBvcnQkMmMzMTM2ZGEwYmYxMzBmOS5nZXRGcmVxdWVuY2llcyh0aGlzLmFuYWx5c2VyLCB0aGlzLnNhbXBsZVJhdGUsIGZmdFJlc3VsdCwgYW5hbHlzaXNUeXBlLCBtaW5EZWNpYmVscywgbWF4RGVjaWJlbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVzdW1lIHRoZSBpbnRlcm5hbCBBdWRpb0NvbnRleHQgaWYgaXQgd2FzIHN1c3BlbmRlZCBkdWUgdG8gdGhlIGxhY2sgb2ZcbiAgICogdXNlciBpbnRlcmFjdGlvbiB3aGVuIHRoZSBBdWRpb0FuYWx5c2lzIHdhcyBpbnN0YW50aWF0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgcmVzdW1lSWZTdXNwZW5kZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSBhd2FpdCB0aGlzLmNvbnRleHQucmVzdW1lKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmdsb2JhbFRoaXMuQXVkaW9BbmFseXNpcyA9ICRmMzJmMDY0NTY0ZWU2MmY2JGV4cG9ydCQyYzMxMzZkYTBiZjEzMGY5O1xuXG5cbmNvbnN0ICQyOWE4YTcwYTk0NjZiMTRmJGV4cG9ydCQ1MGI3NjcwMGUyYjE1ZTkgPSBgXG5jbGFzcyBTdHJlYW1Qcm9jZXNzb3IgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaGFzU3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaGFzSW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDEyODtcbiAgICB0aGlzLndyaXRlID0geyBidWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5idWZmZXJMZW5ndGgpLCB0cmFja0lkOiBudWxsIH07XG4gICAgdGhpcy53cml0ZU9mZnNldCA9IDA7XG4gICAgdGhpcy50cmFja1NhbXBsZU9mZnNldHMgPSB7fTtcbiAgICB0aGlzLnBvcnQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGF0YSkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKHBheWxvYWQuZXZlbnQgPT09ICd3cml0ZScpIHtcbiAgICAgICAgICBjb25zdCBpbnQxNkFycmF5ID0gcGF5bG9hZC5idWZmZXI7XG4gICAgICAgICAgY29uc3QgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShpbnQxNkFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnQxNkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmbG9hdDMyQXJyYXlbaV0gPSBpbnQxNkFycmF5W2ldIC8gMHg4MDAwOyAvLyBDb252ZXJ0IEludDE2IHRvIEZsb2F0MzJcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53cml0ZURhdGEoZmxvYXQzMkFycmF5LCBwYXlsb2FkLnRyYWNrSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHBheWxvYWQuZXZlbnQgPT09ICdvZmZzZXQnIHx8XG4gICAgICAgICAgcGF5bG9hZC5ldmVudCA9PT0gJ2ludGVycnVwdCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcGF5bG9hZC5yZXF1ZXN0SWQ7XG4gICAgICAgICAgY29uc3QgdHJhY2tJZCA9IHRoaXMud3JpdGUudHJhY2tJZDtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0c1t0cmFja0lkXSB8fCAwO1xuICAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogJ29mZnNldCcsXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChwYXlsb2FkLmV2ZW50ID09PSAnaW50ZXJydXB0Jykge1xuICAgICAgICAgICAgdGhpcy5oYXNJbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBVbmhhbmRsZWQgZXZlbnQgXCJcXCR7cGF5bG9hZC5ldmVudH1cIlxcYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgd3JpdGVEYXRhKGZsb2F0MzJBcnJheSwgdHJhY2tJZCA9IG51bGwpIHtcbiAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMud3JpdGU7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMud3JpdGVPZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbG9hdDMyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBmbG9hdDMyQXJyYXlbaV07XG4gICAgICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRCdWZmZXJzLnB1c2godGhpcy53cml0ZSk7XG4gICAgICAgIHRoaXMud3JpdGUgPSB7IGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlckxlbmd0aCksIHRyYWNrSWQgfTtcbiAgICAgICAgYnVmZmVyID0gdGhpcy53cml0ZS5idWZmZXI7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JpdGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm9jZXNzKGlucHV0cywgb3V0cHV0cywgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbMF07XG4gICAgY29uc3Qgb3V0cHV0Q2hhbm5lbERhdGEgPSBvdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0QnVmZmVycyA9IHRoaXMub3V0cHV0QnVmZmVycztcbiAgICBpZiAodGhpcy5oYXNJbnRlcnJ1cHRlZCkge1xuICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHsgZXZlbnQ6ICdzdG9wJyB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG91dHB1dEJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgeyBidWZmZXIsIHRyYWNrSWQgfSA9IG91dHB1dEJ1ZmZlcnMuc2hpZnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q2hhbm5lbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0Q2hhbm5lbERhdGFbaV0gPSBidWZmZXJbaV0gfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFja0lkKSB7XG4gICAgICAgIHRoaXMudHJhY2tTYW1wbGVPZmZzZXRzW3RyYWNrSWRdID1cbiAgICAgICAgICB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0c1t0cmFja0lkXSB8fCAwO1xuICAgICAgICB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0c1t0cmFja0lkXSArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7IGV2ZW50OiAnc3RvcCcgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5yZWdpc3RlclByb2Nlc3Nvcignc3RyZWFtX3Byb2Nlc3NvcicsIFN0cmVhbVByb2Nlc3Nvcik7XG5gO1xuY29uc3QgJDI5YThhNzBhOTQ2NmIxNGYkdmFyJHNjcmlwdCA9IG5ldyBCbG9iKFtcbiAgICAkMjlhOGE3MGE5NDY2YjE0ZiRleHBvcnQkNTBiNzY3MDBlMmIxNWU5XG5dLCB7XG4gICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG59KTtcbmNvbnN0ICQyOWE4YTcwYTk0NjZiMTRmJHZhciRzcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCQyOWE4YTcwYTk0NjZiMTRmJHZhciRzY3JpcHQpO1xuY29uc3QgJDI5YThhNzBhOTQ2NmIxNGYkZXhwb3J0JGJmYThjNTk2MTE0ZDc0ZGYgPSAkMjlhOGE3MGE5NDY2YjE0ZiR2YXIkc3JjO1xuXG5cblxuY2xhc3MgJGQwYTk2OTgzMzk1OGQ5ZTckZXhwb3J0JDk2OThkNjJjNzhiOGYzNjYge1xuICAgIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFdhdlN0cmVhbVBsYXllciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3tzYW1wbGVSYXRlPzogbnVtYmVyfX0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7V2F2U3RyZWFtUGxheWVyfVxuICAgKi8gY29uc3RydWN0b3IoeyBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlID0gNDQxMDAgfSA9IHt9KXtcbiAgICAgICAgdGhpcy5zY3JpcHRTcmMgPSAoMCwgJDI5YThhNzBhOTQ2NmIxNGYkZXhwb3J0JGJmYThjNTk2MTE0ZDc0ZGYpO1xuICAgICAgICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5hbHlzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0cyA9IHt9O1xuICAgICAgICB0aGlzLmludGVycnVwdGVkVHJhY2tJZHMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBhdWRpbyBjb250ZXh0IGFuZCBlbmFibGVzIG91dHB1dCB0byBzcGVha2Vyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoe1xuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zYW1wbGVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fc3BlYWtlcklEKSB0aGlzLmNvbnRleHQuc2V0U2lua0lkKHRoaXMuX3NwZWFrZXJJRCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIpIGF3YWl0IHRoaXMuY29udGV4dC5yZXN1bWUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHRoaXMuc2NyaXB0U3JjKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGFkZCBhdWRpb1dvcmtsZXQgbW9kdWxlOiAke3RoaXMuc2NyaXB0U3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuYWx5c2VyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSA4MTkyO1xuICAgICAgICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSAwLjE7XG4gICAgICAgIHRoaXMuYW5hbHlzZXIgPSBhbmFseXNlcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSBwbGF5aW5nIHRyYWNrXG4gICAqIEBwYXJhbSB7XCJmcmVxdWVuY3lcInxcIm11c2ljXCJ8XCJ2b2ljZVwifSBbYW5hbHlzaXNUeXBlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbkRlY2liZWxzXSBkZWZhdWx0IC0xMDBcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhEZWNpYmVsc10gZGVmYXVsdCAtMzBcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi9hbmFseXNpcy9hdWRpb19hbmFseXNpcy5qcycpLkF1ZGlvQW5hbHlzaXNPdXRwdXRUeXBlfVxuICAgKi8gZ2V0RnJlcXVlbmNpZXMoYW5hbHlzaXNUeXBlID0gXCJmcmVxdWVuY3lcIiwgbWluRGVjaWJlbHMgPSAtMTAwLCBtYXhEZWNpYmVscyA9IC0zMCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5hbHlzZXIpIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWQsIHBsZWFzZSBjYWxsIC5jb25uZWN0KCkgZmlyc3RcIik7XG4gICAgICAgIHJldHVybiAoMCwgJGYzMmYwNjQ1NjRlZTYyZjYkZXhwb3J0JDJjMzEzNmRhMGJmMTMwZjkpLmdldEZyZXF1ZW5jaWVzKHRoaXMuYW5hbHlzZXIsIHRoaXMuc2FtcGxlUmF0ZSwgbnVsbCwgYW5hbHlzaXNUeXBlLCBtaW5EZWNpYmVscywgbWF4RGVjaWJlbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWFrZXIgZGV2aWNlSWRcbiAgICovIGFzeW5jIHVwZGF0ZVNwZWFrZXIoc3BlYWtlcikge1xuICAgICAgICBjb25zdCBfcHJldlNwZWFrZXIgPSB0aGlzLl9zcGVha2VySUQ7XG4gICAgICAgIHRoaXMuX3NwZWFrZXJJRCA9IHNwZWFrZXI7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHRyeSB7XG4gICAgICAgICAgICBpZiAoc3BlYWtlciA9PT0gXCJkZWZhdWx0XCIpIGF3YWl0IHRoaXMuY29udGV4dC5zZXRTaW5rSWQoKTtcbiAgICAgICAgICAgIGVsc2UgYXdhaXQgdGhpcy5jb250ZXh0LnNldFNpbmtJZChzcGVha2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHNldCBzaW5rSWQgdG8gJHtzcGVha2VyfTogJHtlfWApO1xuICAgICAgICAgICAgdGhpcy5fc3BlYWtlcklEID0gX3ByZXZTcGVha2VyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdGFydHMgYXVkaW8gc3RyZWFtaW5nXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gX3N0YXJ0KCkge1xuICAgICAgICBjb25zdCBzdHJlYW1Ob2RlID0gbmV3IEF1ZGlvV29ya2xldE5vZGUodGhpcy5jb250ZXh0LCBcInN0cmVhbV9wcm9jZXNzb3JcIik7XG4gICAgICAgIHN0cmVhbU5vZGUuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICBzdHJlYW1Ob2RlLnBvcnQub25tZXNzYWdlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50OiBldmVudCB9ID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcInN0b3BcIikge1xuICAgICAgICAgICAgICAgIHN0cmVhbU5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFwib2Zmc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZDogcmVxdWVzdElkLCB0cmFja0lkOiB0cmFja0lkLCBvZmZzZXQ6IG9mZnNldCB9ID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gb2Zmc2V0IC8gdGhpcy5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tTYW1wbGVPZmZzZXRzW3JlcXVlc3RJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFuYWx5c2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc3RyZWFtTm9kZS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbU5vZGU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogQWRkcyAxNkJpdFBDTSBkYXRhIHRvIHRoZSBjdXJyZW50bHkgcGxheWluZyBhdWRpbyBzdHJlYW1cbiAgICogWW91IGNhbiBhZGQgY2h1bmtzIGJleW9uZCB0aGUgY3VycmVudCBwbGF5IHBvaW50IGFuZCB0aGV5IHdpbGwgYmUgcXVldWVkIGZvciBwbGF5XG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8SW50MTZBcnJheX0gYXJyYXlCdWZmZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0cmFja0lkXVxuICAgKiBAcmV0dXJucyB7SW50MTZBcnJheX1cbiAgICovIGFkZDE2Qml0UENNKGFycmF5QnVmZmVyLCB0cmFja0lkID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja0lkICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoYHRyYWNrSWQgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmludGVycnVwdGVkVHJhY2tJZHNbdHJhY2tJZF0pIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbSkgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgaWYgKGFycmF5QnVmZmVyIGluc3RhbmNlb2YgSW50MTZBcnJheSkgYnVmZmVyID0gYXJyYXlCdWZmZXI7XG4gICAgICAgIGVsc2UgaWYgKGFycmF5QnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ1ZmZlciA9IG5ldyBJbnQxNkFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50IG11c3QgYmUgSW50MTZBcnJheSBvciBBcnJheUJ1ZmZlcmApO1xuICAgICAgICB0aGlzLnN0cmVhbS5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIndyaXRlXCIsXG4gICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBvZmZzZXQgKHNhbXBsZSBjb3VudCkgb2YgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHN0cmVhbVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnJ1cHRdXG4gICAqIEByZXR1cm5zIHt7dHJhY2tJZDogc3RyaW5nfG51bGwsIG9mZnNldDogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyfX1cbiAgICovIGFzeW5jIGdldFRyYWNrU2FtcGxlT2Zmc2V0KGludGVycnVwdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW0pIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgICB0aGlzLnN0cmVhbS5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGV2ZW50OiBpbnRlcnJ1cHQgPyBcImludGVycnVwdFwiIDogXCJvZmZzZXRcIixcbiAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdHJhY2tTYW1wbGVPZmZzZXQ7XG4gICAgICAgIHdoaWxlKCF0cmFja1NhbXBsZU9mZnNldCl7XG4gICAgICAgICAgICB0cmFja1NhbXBsZU9mZnNldCA9IHRoaXMudHJhY2tTYW1wbGVPZmZzZXRzW3JlcXVlc3RJZF07XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocik9PnNldFRpbWVvdXQoKCk9PnIoKSwgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHJhY2tJZDogdHJhY2tJZCB9ID0gdHJhY2tTYW1wbGVPZmZzZXQ7XG4gICAgICAgIGlmIChpbnRlcnJ1cHQgJiYgdHJhY2tJZCkgdGhpcy5pbnRlcnJ1cHRlZFRyYWNrSWRzW3RyYWNrSWRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2FtcGxlT2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICogU3RyaXBzIHRoZSBjdXJyZW50IHN0cmVhbSBhbmQgcmV0dXJucyB0aGUgc2FtcGxlIG9mZnNldCBvZiB0aGUgYXVkaW9cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJydXB0XVxuICAgKiBAcmV0dXJucyB7e3RyYWNrSWQ6IHN0cmluZ3xudWxsLCBvZmZzZXQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcn19XG4gICAqLyBhc3luYyBpbnRlcnJ1cHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYWNrU2FtcGxlT2Zmc2V0KHRydWUpO1xuICAgIH1cbn1cbmdsb2JhbFRoaXMuV2F2U3RyZWFtUGxheWVyID0gJGQwYTk2OTgzMzk1OGQ5ZTckZXhwb3J0JDk2OThkNjJjNzhiOGYzNjY7XG5cblxuY29uc3QgJDhlMWQxZTZmZjA4ZjZmYjUkdmFyJEF1ZGlvUHJvY2Vzc29yV29ya2xldCA9IGBcbmNsYXNzIEF1ZGlvUHJvY2Vzc29yIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucG9ydC5vbm1lc3NhZ2UgPSB0aGlzLnJlY2VpdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5mb3VuZEF1ZGlvID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBzYW1wbGVkIGNodW5rcyBpbnRvIGNoYW5uZWxzXG4gICAqIEZvcm1hdCBpcyBjaHVua1tMZWZ0W10sIFJpZ2h0W11dXG4gICAqL1xuICByZWFkQ2hhbm5lbERhdGEoY2h1bmtzLCBjaGFubmVsID0gLTEsIG1heENoYW5uZWxzID0gOSkge1xuICAgIGxldCBjaGFubmVsTGltaXQ7XG4gICAgaWYgKGNoYW5uZWwgIT09IC0xKSB7XG4gICAgICBpZiAoY2h1bmtzWzBdICYmIGNodW5rc1swXS5sZW5ndGggLSAxIDwgY2hhbm5lbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXFxgQ2hhbm5lbCBcXCR7Y2hhbm5lbH0gb3V0IG9mIHJhbmdlOiBtYXggXFwke2NodW5rc1swXS5sZW5ndGh9XFxgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGFubmVsTGltaXQgPSBjaGFubmVsICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbCA9IDA7XG4gICAgICBjaGFubmVsTGltaXQgPSBNYXRoLm1pbihjaHVua3NbMF0gPyBjaHVua3NbMF0ubGVuZ3RoIDogMSwgbWF4Q2hhbm5lbHMpO1xuICAgIH1cbiAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSBjaGFubmVsOyBuIDwgY2hhbm5lbExpbWl0OyBuKyspIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGNodW5rcy5yZWR1Y2UoKHN1bSwgY2h1bmspID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGNodW5rW25dLmxlbmd0aDtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgYnVmZmVycyA9IGNodW5rcy5tYXAoKGNodW5rKSA9PiBjaHVua1tuXSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQuc2V0KGJ1ZmZlcnNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBidWZmZXJzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWxzW25dID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbHM7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZXMgcGFyYWxsZWwgYXVkaW8gZGF0YSBpbnRvIGNvcnJlY3QgZm9ybWF0LFxuICAgKiBjaGFubmVsc1tMZWZ0W10sIFJpZ2h0W11dIHRvIGZsb2F0MzJBcnJheVtMUkxSTFJMUi4uLl1cbiAgICovXG4gIGZvcm1hdEF1ZGlvRGF0YShjaGFubmVscykge1xuICAgIGlmIChjaGFubmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFNpbXBsZSBjYXNlIGlzIG9ubHkgb25lIGNoYW5uZWxcbiAgICAgIGNvbnN0IGZsb2F0MzJBcnJheSA9IGNoYW5uZWxzWzBdLnNsaWNlKCk7XG4gICAgICBjb25zdCBtZWFuVmFsdWVzID0gY2hhbm5lbHNbMF0uc2xpY2UoKTtcbiAgICAgIHJldHVybiB7IGZsb2F0MzJBcnJheSwgbWVhblZhbHVlcyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBjaGFubmVsc1swXS5sZW5ndGggKiBjaGFubmVscy5sZW5ndGhcbiAgICAgICk7XG4gICAgICBjb25zdCBtZWFuVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShjaGFubmVsc1swXS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVsc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogY2hhbm5lbHMubGVuZ3RoO1xuICAgICAgICBsZXQgbWVhblZhbHVlID0gMDtcbiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBjaGFubmVscy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgIGZsb2F0MzJBcnJheVtvZmZzZXQgKyBuXSA9IGNoYW5uZWxzW25dW2ldO1xuICAgICAgICAgIG1lYW5WYWx1ZSArPSBjaGFubmVsc1tuXVtpXTtcbiAgICAgICAgfVxuICAgICAgICBtZWFuVmFsdWVzW2ldID0gbWVhblZhbHVlIC8gY2hhbm5lbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZmxvYXQzMkFycmF5LCBtZWFuVmFsdWVzIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIDMyLWJpdCBmbG9hdCBkYXRhIHRvIDE2LWJpdCBpbnRlZ2Vyc1xuICAgKi9cbiAgZmxvYXRUbzE2Qml0UENNKGZsb2F0MzJBcnJheSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmbG9hdDMyQXJyYXkubGVuZ3RoICogMik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMkFycmF5Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gMikge1xuICAgICAgbGV0IHMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZmxvYXQzMkFycmF5W2ldKSk7XG4gICAgICB2aWV3LnNldEludDE2KG9mZnNldCwgcyA8IDAgPyBzICogMHg4MDAwIDogcyAqIDB4N2ZmZiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBtb3N0IHJlY2VudCBhbXBsaXR1ZGUgdmFsdWVzIGZyb20gdGhlIGF1ZGlvIHN0cmVhbVxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbFxuICAgKi9cbiAgZ2V0VmFsdWVzKGNoYW5uZWwgPSAtMSkge1xuICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5yZWFkQ2hhbm5lbERhdGEodGhpcy5jaHVua3MsIGNoYW5uZWwpO1xuICAgIGNvbnN0IHsgbWVhblZhbHVlcyB9ID0gdGhpcy5mb3JtYXRBdWRpb0RhdGEoY2hhbm5lbHMpO1xuICAgIHJldHVybiB7IG1lYW5WYWx1ZXMsIGNoYW5uZWxzIH07XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0cyBjaHVua3MgYXMgYW4gYXVkaW8vd2F2IGZpbGVcbiAgICovXG4gIGV4cG9ydCgpIHtcbiAgICBjb25zdCBjaGFubmVscyA9IHRoaXMucmVhZENoYW5uZWxEYXRhKHRoaXMuY2h1bmtzKTtcbiAgICBjb25zdCB7IGZsb2F0MzJBcnJheSwgbWVhblZhbHVlcyB9ID0gdGhpcy5mb3JtYXRBdWRpb0RhdGEoY2hhbm5lbHMpO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHRoaXMuZmxvYXRUbzE2Qml0UENNKGZsb2F0MzJBcnJheSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lYW5WYWx1ZXM6IG1lYW5WYWx1ZXMsXG4gICAgICBhdWRpbzoge1xuICAgICAgICBiaXRzUGVyU2FtcGxlOiAxNixcbiAgICAgICAgY2hhbm5lbHM6IGNoYW5uZWxzLFxuICAgICAgICBkYXRhOiBhdWRpb0RhdGEsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZWNlaXZlKGUpIHtcbiAgICBjb25zdCB7IGV2ZW50LCBpZCB9ID0gZS5kYXRhO1xuICAgIGxldCByZWNlaXB0RGF0YSA9IHt9O1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0b3AnOlxuICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsZWFyJzpcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgcmVjZWlwdERhdGEgPSB0aGlzLmV4cG9ydCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlYWQnOlxuICAgICAgICByZWNlaXB0RGF0YSA9IHRoaXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBzZW5kIGJhY2sgcmVjZWlwdFxuICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7IGV2ZW50OiAncmVjZWlwdCcsIGlkLCBkYXRhOiByZWNlaXB0RGF0YSB9KTtcbiAgfVxuXG4gIHNlbmRDaHVuayhjaHVuaykge1xuICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5yZWFkQ2hhbm5lbERhdGEoW2NodW5rXSk7XG4gICAgY29uc3QgeyBmbG9hdDMyQXJyYXksIG1lYW5WYWx1ZXMgfSA9IHRoaXMuZm9ybWF0QXVkaW9EYXRhKGNoYW5uZWxzKTtcbiAgICBjb25zdCByYXdBdWRpb0RhdGEgPSB0aGlzLmZsb2F0VG8xNkJpdFBDTShmbG9hdDMyQXJyYXkpO1xuICAgIGNvbnN0IG1vbm9BdWRpb0RhdGEgPSB0aGlzLmZsb2F0VG8xNkJpdFBDTShtZWFuVmFsdWVzKTtcbiAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgZXZlbnQ6ICdjaHVuaycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1vbm86IG1vbm9BdWRpb0RhdGEsXG4gICAgICAgIHJhdzogcmF3QXVkaW9EYXRhLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByb2Nlc3MoaW5wdXRMaXN0LCBvdXRwdXRMaXN0LCBwYXJhbWV0ZXJzKSB7XG4gICAgLy8gQ29weSBpbnB1dCB0byBvdXRwdXQgKGUuZy4gc3BlYWtlcnMpXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgY3JlYXRlcyBjaG9wcHkgc291bmRzIHdpdGggTWFjIHByb2R1Y3RzXG4gICAgY29uc3Qgc291cmNlTGltaXQgPSBNYXRoLm1pbihpbnB1dExpc3QubGVuZ3RoLCBvdXRwdXRMaXN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5wdXROdW0gPSAwOyBpbnB1dE51bSA8IHNvdXJjZUxpbWl0OyBpbnB1dE51bSsrKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0TGlzdFtpbnB1dE51bV07XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRMaXN0W2lucHV0TnVtXTtcbiAgICAgIGNvbnN0IGNoYW5uZWxDb3VudCA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgb3V0cHV0Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBjaGFubmVsTnVtID0gMDsgY2hhbm5lbE51bSA8IGNoYW5uZWxDb3VudDsgY2hhbm5lbE51bSsrKSB7XG4gICAgICAgIGlucHV0W2NoYW5uZWxOdW1dLmZvckVhY2goKHNhbXBsZSwgaSkgPT4ge1xuICAgICAgICAgIG91dHB1dFtjaGFubmVsTnVtXVtpXSA9IHNhbXBsZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0TGlzdFswXTtcbiAgICAvLyBUaGVyZSdzIGxhdGVuY3kgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHN0cmVhbSBiZWZvcmUgcmVjb3JkaW5nIHN0YXJ0c1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSByZWNlaXZlIGF1ZGlvIGRhdGEgYmVmb3JlIHdlIHN0YXJ0IHN0b3JpbmcgY2h1bmtzXG4gICAgbGV0IHNsaWNlSW5kZXggPSAwO1xuICAgIGlmICghdGhpcy5mb3VuZEF1ZGlvKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgaW5wdXRzKSB7XG4gICAgICAgIHNsaWNlSW5kZXggPSAwOyAvLyByZXNldCBmb3IgZWFjaCBjaGFubmVsXG4gICAgICAgIGlmICh0aGlzLmZvdW5kQXVkaW8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgY2hhbm5lbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGZpbmQgb25seSBvbmUgbm9uLXplcm8gZW50cnkgaW4gYW55IGNoYW5uZWxcbiAgICAgICAgICAgICAgdGhpcy5mb3VuZEF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzbGljZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dHMgJiYgaW5wdXRzWzBdICYmIHRoaXMuZm91bmRBdWRpbyAmJiB0aGlzLnJlY29yZGluZykge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb3B5IHRoZSBUeXBlZEFycmF5LCBiZWNhdXNlIHRoZSBcXGBwcm9jZXNzXFxgXG4gICAgICAvLyBpbnRlcm5hbHMgd2lsbCByZXVzZSB0aGUgc2FtZSBidWZmZXIgdG8gaG9sZCBlYWNoIGlucHV0XG4gICAgICBjb25zdCBjaHVuayA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5zbGljZShzbGljZUluZGV4KSk7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIHRoaXMuc2VuZENodW5rKGNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxucmVnaXN0ZXJQcm9jZXNzb3IoJ2F1ZGlvX3Byb2Nlc3NvcicsIEF1ZGlvUHJvY2Vzc29yKTtcbmA7XG5jb25zdCAkOGUxZDFlNmZmMDhmNmZiNSR2YXIkc2NyaXB0ID0gbmV3IEJsb2IoW1xuICAgICQ4ZTFkMWU2ZmYwOGY2ZmI1JHZhciRBdWRpb1Byb2Nlc3NvcldvcmtsZXRcbl0sIHtcbiAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbn0pO1xuY29uc3QgJDhlMWQxZTZmZjA4ZjZmYjUkdmFyJHNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoJDhlMWQxZTZmZjA4ZjZmYjUkdmFyJHNjcmlwdCk7XG5jb25zdCAkOGUxZDFlNmZmMDhmNmZiNSRleHBvcnQkMWY2NWY1MGE4Y2JmZjQzYyA9ICQ4ZTFkMWU2ZmYwOGY2ZmI1JHZhciRzcmM7XG5cblxuXG5cbmNsYXNzICQ2MmJjMzc2MDQ0YTA1NTEzJGV4cG9ydCQ0MzliMjE3Y2E2NTlhODc3IHtcbiAgICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFdhdlJlY29yZGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7e3NhbXBsZVJhdGU/OiBudW1iZXIsIG91dHB1dFRvU3BlYWtlcnM/OiBib29sZWFuLCBkZWJ1Zz86IGJvb2xlYW59fSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1dhdlJlY29yZGVyfVxuICAgKi8gY29uc3RydWN0b3IoeyBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlID0gNDQxMDAsIG91dHB1dFRvU3BlYWtlcnM6IG91dHB1dFRvU3BlYWtlcnMgPSBmYWxzZSwgZGVidWc6IGRlYnVnID0gZmFsc2UgfSA9IHt9KXtcbiAgICAgICAgLy8gU2NyaXB0IHNvdXJjZVxuICAgICAgICB0aGlzLnNjcmlwdFNyYyA9ICgwLCAkOGUxZDFlNmZmMDhmNmZiNSRleHBvcnQkMWY2NWY1MGE4Y2JmZjQzYyk7XG4gICAgICAgIC8vIENvbmZpZ1xuICAgICAgICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICAgICAgICB0aGlzLm91dHB1dFRvU3BlYWtlcnMgPSBvdXRwdXRUb1NwZWFrZXJzO1xuICAgICAgICB0aGlzLmRlYnVnID0gISFkZWJ1ZztcbiAgICAgICAgdGhpcy5fZGV2aWNlQ2hhbmdlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZXZpY2VFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGV2aWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmRldmljZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFN0YXRlIHZhcmlhYmxlc1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBFdmVudCBoYW5kbGluZyB3aXRoIEF1ZGlvV29ya2xldFxuICAgICAgICB0aGlzLl9sYXN0RXZlbnRJZCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRSZWNlaXB0cyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VGltZW91dCA9IDUwMDA7XG4gICAgICAgIC8vIFByb2Nlc3MgY2h1bmtzIG9mIGF1ZGlvXG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yID0gKCk9Pnt9O1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIERlY29kZXMgYXVkaW8gZGF0YSBmcm9tIG11bHRpcGxlIGZvcm1hdHMgdG8gYSBCbG9iLCB1cmwsIEZsb2F0MzJBcnJheSBhbmQgQXVkaW9CdWZmZXJcbiAgICogQHBhcmFtIHtCbG9ifEZsb2F0MzJBcnJheXxJbnQxNkFycmF5fEFycmF5QnVmZmVyfG51bWJlcltdfSBhdWRpb0RhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVJhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21TYW1wbGVSYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERlY29kZWRBdWRpb1R5cGU+fVxuICAgKi8gc3RhdGljIGFzeW5jIGRlY29kZShhdWRpb0RhdGEsIHNhbXBsZVJhdGUgPSA0NDEwMCwgZnJvbVNhbXBsZVJhdGUgPSAtMSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYXJyYXlCdWZmZXI7XG4gICAgICAgIGxldCBibG9iO1xuICAgICAgICBpZiAoYXVkaW9EYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgaWYgKGZyb21TYW1wbGVSYXRlICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHNwZWNpZnkgXCJmcm9tU2FtcGxlUmF0ZVwiIHdoZW4gcmVhZGluZyBmcm9tIEJsb2JgKTtcbiAgICAgICAgICAgIGJsb2IgPSBhdWRpb0RhdGE7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdWRpb0RhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGZyb21TYW1wbGVSYXRlICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHNwZWNpZnkgXCJmcm9tU2FtcGxlUmF0ZVwiIHdoZW4gcmVhZGluZyBmcm9tIEFycmF5QnVmZmVyYCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IGF1ZGlvRGF0YTtcbiAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbXG4gICAgICAgICAgICAgICAgYXJyYXlCdWZmZXJcbiAgICAgICAgICAgIF0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXVkaW8vd2F2J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmxvYXQzMkFycmF5O1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhdWRpb0RhdGE7XG4gICAgICAgICAgICAgICAgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdWRpb0RhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXVkaW9EYXRhLmxlbmd0aDsgaSsrKWZsb2F0MzJBcnJheVtpXSA9IGF1ZGlvRGF0YVtpXSAvIDB4ODAwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXVkaW9EYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSBmbG9hdDMyQXJyYXkgPSBhdWRpb0RhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChhdWRpb0RhdGEgaW5zdGFuY2VvZiBBcnJheSkgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdWRpb0RhdGEpO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFwiYXVkaW9EYXRhXCIgbXVzdCBiZSBvbmUgb2Y6IEJsb2IsIEZsb2F0MzJBcnJyYXksIEludDE2QXJyYXksIEFycmF5QnVmZmVyLCBBcnJheTxudW1iZXI+YCk7XG4gICAgICAgICAgICBpZiAoZnJvbVNhbXBsZVJhdGUgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYE11c3Qgc3BlY2lmeSBcImZyb21TYW1wbGVSYXRlXCIgd2hlbiByZWFkaW5nIGZyb20gRmxvYXQzMkFycmF5LCBJbjE2QXJyYXkgb3IgQXJyYXlgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21TYW1wbGVSYXRlIDwgMzAwMCkgdGhyb3cgbmV3IEVycm9yKGBNaW5pbXVtIFwiZnJvbVNhbXBsZVJhdGVcIiBpcyAzMDAwICgza0h6KWApO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSBkYXRhID0gKDAsICQ2ZDRiNzQ0OWExZTE1NDRhJGV4cG9ydCQxM2FmZGEyMzdiMWM5ODQ2KS5mbG9hdFRvMTZCaXRQQ00oZmxvYXQzMkFycmF5KTtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0ge1xuICAgICAgICAgICAgICAgIGJpdHNQZXJTYW1wbGU6IDE2LFxuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiBbXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tlciA9IG5ldyAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYWNrZXIucGFjayhmcm9tU2FtcGxlUmF0ZSwgYXVkaW8pO1xuICAgICAgICAgICAgYmxvYiA9IHJlc3VsdC5ibG9iO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSBhd2FpdCBjb250ZXh0LmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvYjogYmxvYixcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICBhdWRpb0J1ZmZlcjogYXVkaW9CdWZmZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIExvZ3MgZGF0YSBpbiBkZWJ1ZyBtb2RlXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmd1bWVudHNcbiAgICogQHJldHVybnMge3RydWV9XG4gICAqLyBsb2coKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB0aGlzLmxvZyguLi5hcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzYW1wbGVSYXRlIGZvciB0aGUgcmVjb3JkZXJcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovIGdldFNhbXBsZVJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbXBsZVJhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSByZWNvcmRpbmdcbiAgICogQHJldHVybnMge1wiZW5kZWRcInxcInBhdXNlZFwifFwicmVjb3JkaW5nXCJ9XG4gICAqLyBnZXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHJldHVybiAnZW5kZWQnO1xuICAgICAgICBlbHNlIGlmICghdGhpcy5yZWNvcmRpbmcpIHJldHVybiAncGF1c2VkJztcbiAgICAgICAgZWxzZSByZXR1cm4gJ3JlY29yZGluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgQXVkaW9Xb3JrbGV0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7e1trZXk6IHN0cmluZ106IGFueX19IGRhdGFcbiAgICogQHBhcmFtIHtBdWRpb1dvcmtsZXROb2RlfSBbX3Byb2Nlc3Nvcl1cbiAgICogQHJldHVybnMge1Byb21pc2U8e1trZXk6IHN0cmluZ106IGFueX0+fVxuICAgKi8gYXN5bmMgX2V2ZW50KG5hbWUsIGRhdGEgPSB7fSwgX3Byb2Nlc3NvciA9IG51bGwpIHtcbiAgICAgICAgX3Byb2Nlc3NvciA9IF9wcm9jZXNzb3IgfHwgdGhpcy5wcm9jZXNzb3I7XG4gICAgICAgIGlmICghX3Byb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHNlbmQgZXZlbnRzIHdpdGhvdXQgcmVjb3JkaW5nIGZpcnN0Jyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBldmVudDogbmFtZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9sYXN0RXZlbnRJZCsrLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBfcHJvY2Vzc29yLnBvcnQucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHQwID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHdoaWxlKCF0aGlzLmV2ZW50UmVjZWlwdHNbbWVzc2FnZS5pZF0pe1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdDAgPiB0aGlzLmV2ZW50VGltZW91dCkgdGhyb3cgbmV3IEVycm9yKGBUaW1lb3V0IHdhaXRpbmcgZm9yIFwiJHtuYW1lfVwiIGV2ZW50YCk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dCgoKT0+cmVzKHRydWUpLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIGRldmljZSBjaGFuZ2UgY2FsbGJhY2ssIHJlbW92ZSBpZiBjYWxsYmFjayBwcm92aWRlZCBpcyBgbnVsbGBcbiAgICogQHBhcmFtIHsoQXJyYXk8TWVkaWFEZXZpY2VJbmZvICYge2RlZmF1bHQ6IGJvb2xlYW59Pik6IHZvaWR8bnVsbH0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3RydWV9XG4gICAqLyBsaXN0ZW5Gb3JEZXZpY2VDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSBudWxsICYmIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQmFzaWNhbGx5IGEgZGVib3VuY2U7IHdlIG9ubHkgd2FudCB0aGlzIGNhbGxlZCBvbmNlIHdoZW4gZGV2aWNlcyBjaGFuZ2VcbiAgICAgICAgICAgIC8vIEFuZCB3ZSBvbmx5IHdhbnQgdGhlIG1vc3QgcmVjZW50IGNhbGxiYWNrKCkgdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgIC8vIGlmIGEgZmV3IGFyZSBvcGVyYXRpbmcgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgICAgbGV0IGxhc3RJZCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdERldmljZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZURldmljZXMgPSAoZGV2aWNlcyk9PmRldmljZXMubWFwKChkKT0+ZC5kZXZpY2VJZCkuc29ydCgpLmpvaW4oJywnKTtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSArK2xhc3RJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgdGhpcy5saXN0RGV2aWNlcygpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gbGFzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVEZXZpY2VzKGxhc3REZXZpY2VzKSAhPT0gc2VyaWFsaXplRGV2aWNlcyhkZXZpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERldmljZXMgPSBkZXZpY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGV2aWNlcy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIGNiKTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VDaGFuZ2VDYWxsYmFjayA9IGNiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJvdmlkZSBhIGNhbGxiYWNrIGZvciBpZi93aGVuIGRldmljZSBlcnJvcnMgb2NjdXJcbiAgICogQHBhcmFtIHsoKHtkZXZpY2VzOiBBcnJheTxcImNhbVwiIHwgXCJtaWNcIj4sIHR5cGU6IHN0cmluZywgZXJyb3I/OiBFcnJvcn0pID0+IHZvaWQpIHwgbnVsbH0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3RydWV9XG4gICAqLyBsaXN0ZW5Gb3JEZXZpY2VFcnJvcnMoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZGV2aWNlRXJyb3JDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICogTWFudWFsbHkgcmVxdWVzdCBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgbWljcm9waG9uZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIHJlcXVlc3RQZXJtaXNzaW9uKCkge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uU3RhdHVzID0gYXdhaXQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgIG5hbWU6ICdtaWNyb3Bob25lJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBlcm1pc3Npb25TdGF0dXMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGV2aWNlRXJyb3JDYWxsYmFjaykgdGhpcy5fZGV2aWNlRXJyb3JDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgZGV2aWNlczogW1xuICAgICAgICAgICAgICAgICAgICBcIm1pY1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiTWljcm9waG9uZSBhY2Nlc3MgZGVuaWVkXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtaXNzaW9uU3RhdHVzLnN0YXRlID09PSAncHJvbXB0JykgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICAgICAgICBhdWRpbzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICAgICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spPT50cmFjay5zdG9wKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWNjZXNzaW5nIG1pY3JvcGhvbmUuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RldmljZUVycm9yQ2FsbGJhY2spIHRoaXMuX2RldmljZUVycm9yQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGRldmljZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJtaWNcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogTGlzdCBhbGwgZWxpZ2libGUgZGV2aWNlcyBmb3IgcmVjb3JkaW5nLCB3aWxsIHJlcXVlc3QgcGVybWlzc2lvbiB0byB1c2UgbWljcm9waG9uZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8gJiB7ZGVmYXVsdDogYm9vbGVhbn0+Pn1cbiAgICovIGFzeW5jIGxpc3REZXZpY2VzKCkge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMgfHwgISgnZW51bWVyYXRlRGV2aWNlcycgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykpIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlcXVlc3QgdXNlciBkZXZpY2VzJyk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICBjb25zdCBhdWRpb0RldmljZXMgPSBkZXZpY2VzLmZpbHRlcigoZGV2aWNlKT0+ZGV2aWNlLmtpbmQgPT09ICdhdWRpb2lucHV0Jyk7XG4gICAgICAgIHJldHVybiBhdWRpb0RldmljZXM7XG4gICAgLy8gY29uc3QgZGVmYXVsdERldmljZUluZGV4ID0gYXVkaW9EZXZpY2VzLmZpbmRJbmRleChcbiAgICAvLyAgIChkZXZpY2UpID0+IGRldmljZS5kZXZpY2VJZCA9PT0gJ2RlZmF1bHQnXG4gICAgLy8gKTtcbiAgICAvLyBjb25zdCBkZXZpY2VMaXN0ID0gW107XG4gICAgLy8gaWYgKGRlZmF1bHREZXZpY2VJbmRleCAhPT0gLTEpIHtcbiAgICAvLyAgIGxldCBkZWZhdWx0RGV2aWNlID0gYXVkaW9EZXZpY2VzLnNwbGljZShkZWZhdWx0RGV2aWNlSW5kZXgsIDEpWzBdO1xuICAgIC8vICAgbGV0IGV4aXN0aW5nSW5kZXggPSBhdWRpb0RldmljZXMuZmluZEluZGV4KFxuICAgIC8vICAgICAoZGV2aWNlKSA9PiBkZXZpY2UuZ3JvdXBJZCA9PT0gZGVmYXVsdERldmljZS5ncm91cElkXG4gICAgLy8gICApO1xuICAgIC8vICAgaWYgKGV4aXN0aW5nSW5kZXggIT09IC0xKSB7XG4gICAgLy8gICAgIGRlZmF1bHREZXZpY2UgPSBhdWRpb0RldmljZXMuc3BsaWNlKGV4aXN0aW5nSW5kZXgsIDEpWzBdO1xuICAgIC8vICAgfVxuICAgIC8vICAgZGVmYXVsdERldmljZS5kZWZhdWx0ID0gdHJ1ZTtcbiAgICAvLyAgIGRldmljZUxpc3QucHVzaChkZWZhdWx0RGV2aWNlKTtcbiAgICAvLyB9XG4gICAgLy8gcmV0dXJuIGRldmljZUxpc3QuY29uY2F0KGF1ZGlvRGV2aWNlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBCZWdpbnMgYSByZWNvcmRpbmcgc2Vzc2lvbiBhbmQgcmVxdWVzdHMgbWljcm9waG9uZSBwZXJtaXNzaW9ucyBpZiBub3QgYWxyZWFkeSBncmFudGVkXG4gICAqIE1pY3JvcGhvbmUgcmVjb3JkaW5nIGluZGljYXRvciB3aWxsIGFwcGVhciBvbiBicm93c2VyIHRhYiBidXQgc3RhdHVzIHdpbGwgYmUgXCJwYXVzZWRcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RldmljZUlkXSBpZiBubyBkZXZpY2UgcHJvdmlkZWQsIGRlZmF1bHQgZGV2aWNlIHdpbGwgYmUgdXNlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIGJlZ2luKGRldmljZUlkKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKGBBbHJlYWR5IGNvbm5lY3RlZDogcGxlYXNlIGNhbGwgLmVuZCgpIHRvIHN0YXJ0IGEgbmV3IHNlc3Npb25gKTtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIHx8ICEoJ2dldFVzZXJNZWRpYScgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2VFcnJvckNhbGxiYWNrKSB0aGlzLl9kZXZpY2VFcnJvckNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBkZXZpY2VzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibWljXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2FtXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5kZWZpbmVkLW1lZGlhZGV2aWNlc1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlcXVlc3QgdXNlciBtZWRpYScpO1xuICAgICAgICB9XG4gICAgICAgIGRldmljZUlkID0gZGV2aWNlSWQgPz8gdGhpcy5kZXZpY2VTZWxlY3Rpb24/LmRldmljZUlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRldmljZUlkKSBjb25maWcuYXVkaW8gPSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uZmlnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGV2aWNlRXJyb3JDYWxsYmFjaykgdGhpcy5fZGV2aWNlRXJyb3JDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgZGV2aWNlczogW1xuICAgICAgICAgICAgICAgICAgICBcIm1pY1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHN0YXJ0IG1lZGlhIHN0cmVhbScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdERldmljZXMoKS50aGVuKChkZXZpY2VzKT0+e1xuICAgICAgICAgICAgZGV2aWNlSWQgPSB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZmluZCBjdXJyZW50IGRldmljZScsIGRldmljZXMsIGRldmljZUlkLCB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLmdldFNldHRpbmdzKCkpO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2VTZWxlY3Rpb24gPSBkZXZpY2VzLmZpbmQoKGQpPT5kLmRldmljZUlkID09PSBkZXZpY2VJZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY3VycmVudCBkZXZpY2UnLCB0aGlzLmRldmljZVNlbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiB0aGlzLnNhbXBsZVJhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW0pO1xuICAgICAgICAvLyBMb2FkIGFuZCBleGVjdXRlIHRoZSBtb2R1bGUgc2NyaXB0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHRoaXMuc2NyaXB0U3JjKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGFkZCBhdWRpb1dvcmtsZXQgbW9kdWxlOiAke3RoaXMuc2NyaXB0U3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBBdWRpb1dvcmtsZXROb2RlKGNvbnRleHQsICdhdWRpb19wcm9jZXNzb3InKTtcbiAgICAgICAgcHJvY2Vzc29yLnBvcnQub25tZXNzYWdlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50OiBldmVudCwgaWQ6IGlkLCBkYXRhOiBkYXRhIH0gPSBlLmRhdGE7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdyZWNlaXB0JykgdGhpcy5ldmVudFJlY2VpcHRzW2lkXSA9IGRhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gJ2NodW5rJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpLm1lcmdlQnVmZmVycyhidWZmZXIucmF3LCBkYXRhLnJhdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtb25vOiAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpLm1lcmdlQnVmZmVycyhidWZmZXIubW9ubywgZGF0YS5tb25vKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIubW9uby5ieXRlTGVuZ3RoID49IHRoaXMuX2NodW5rUHJvY2Vzc29yU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3IodGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9ubzogbmV3IEFycmF5QnVmZmVyKDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuX2NodW5rUHJvY2Vzc29yKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gc291cmNlLmNvbm5lY3QocHJvY2Vzc29yKTtcbiAgICAgICAgY29uc3QgYW5hbHlzZXIgPSBjb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSA4MTkyO1xuICAgICAgICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSAwLjE7XG4gICAgICAgIG5vZGUuY29ubmVjdChhbmFseXNlcik7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRvU3BlYWtlcnMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBPdXRwdXQgdG8gc3BlYWtlcnMgbWF5IGFmZmVjdCBzb3VuZCBxdWFsaXR5LFxcbmVzcGVjaWFsbHkgZHVlIHRvIHN5c3RlbSBhdWRpbyBmZWVkYmFjayBwcmV2ZW50YXRpdmUgbWVhc3VyZXMuXFxudXNlIG9ubHkgZm9yIGRlYnVnZ2luZ1wiKTtcbiAgICAgICAgICAgIGFuYWx5c2VyLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuYW5hbHlzZXIgPSBhbmFseXNlcjtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIGNvbnNvbGUubG9nKCdiZWdpbiBjb21wbGV0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSByZWNvcmRpbmcgdHJhY2tcbiAgICogQHBhcmFtIHtcImZyZXF1ZW5jeVwifFwibXVzaWNcInxcInZvaWNlXCJ9IFthbmFseXNpc1R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRGVjaWJlbHNdIGRlZmF1bHQgLTEwMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heERlY2liZWxzXSBkZWZhdWx0IC0zMFxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2FuYWx5c2lzL2F1ZGlvX2FuYWx5c2lzLmpzJykuQXVkaW9BbmFseXNpc091dHB1dFR5cGV9XG4gICAqLyBnZXRGcmVxdWVuY2llcyhhbmFseXNpc1R5cGUgPSAnZnJlcXVlbmN5JywgbWluRGVjaWJlbHMgPSAtMTAwLCBtYXhEZWNpYmVscyA9IC0zMCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybiAoMCwgJGYzMmYwNjQ1NjRlZTYyZjYkZXhwb3J0JDJjMzEzNmRhMGJmMTMwZjkpLmdldEZyZXF1ZW5jaWVzKHRoaXMuYW5hbHlzZXIsIHRoaXMuc2FtcGxlUmF0ZSwgbnVsbCwgYW5hbHlzaXNUeXBlLCBtaW5EZWNpYmVscywgbWF4RGVjaWJlbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGF1c2VzIHRoZSByZWNvcmRpbmdcbiAgICogS2VlcHMgbWljcm9waG9uZSBzdHJlYW0gb3BlbiBidXQgaGFsdHMgc3RvcmFnZSBvZiBhdWRpb1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIHBhdXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnJlY29yZGluZykgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHBhdXNlZDogcGxlYXNlIGNhbGwgLnJlY29yZCgpIGZpcnN0Jyk7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlci5yYXcuYnl0ZUxlbmd0aCkgdGhpcy5fY2h1bmtQcm9jZXNzb3IodGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIpO1xuICAgICAgICB0aGlzLmxvZygnUGF1c2luZyAuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoJ3N0b3AnKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdGFydCByZWNvcmRpbmcgc3RyZWFtIGFuZCBzdG9yaW5nIHRvIG1lbW9yeSBmcm9tIHRoZSBjb25uZWN0ZWQgYXVkaW8gc291cmNlXG4gICAqIEBwYXJhbSB7KGRhdGE6IHsgbW9ubzogSW50MTZBcnJheTsgcmF3OiBJbnQxNkFycmF5IH0pID0+IGFueX0gW2NodW5rUHJvY2Vzc29yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NodW5rU2l6ZV0gY2h1bmtQcm9jZXNzb3Igd2lsbCBub3QgYmUgdHJpZ2dlcmVkIHVudGlsIHRoaXMgc2l6ZSB0aHJlc2hvbGQgbWV0IGluIG1vbm8gYXVkaW9cbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyByZWNvcmQoY2h1bmtQcm9jZXNzb3IgPSAoKT0+e30sIGNodW5rU2l6ZSA9IDgxOTIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIGVuZGVkOiBwbGVhc2UgY2FsbCAuYmVnaW4oKSBmaXJzdCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnJlY29yZGluZykgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlY29yZGluZzogcGxlYXNlIGNhbGwgLnBhdXNlKCkgZmlyc3QnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rUHJvY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoYGNodW5rUHJvY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvbmApO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvciA9IGNodW5rUHJvY2Vzc29yO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUgPSBjaHVua1NpemU7XG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coJ1JlY29yZGluZyAuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoJ3N0YXJ0Jyk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDbGVhcnMgdGhlIGF1ZGlvIGJ1ZmZlciwgZW1wdGllcyBzdG9yZWQgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgY2xlYXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3QnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoJ2NsZWFyJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVhZHMgdGhlIGN1cnJlbnQgYXVkaW8gc3RyZWFtIGRhdGFcbiAgICogQHJldHVybnMge1Byb21pc2U8e21lYW5WYWx1ZXM6IEZsb2F0MzJBcnJheSwgY2hhbm5lbHM6IEFycmF5PEZsb2F0MzJBcnJheT59Pn1cbiAgICovIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3QnKTtcbiAgICAgICAgdGhpcy5sb2coJ1JlYWRpbmcgLi4uJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V2ZW50KCdyZWFkJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBhdWRpbyBzdHJlYW0gdG8gYSBmaWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSBGb3JjZSBzYXZpbmcgd2hpbGUgc3RpbGwgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi93YXZfcGFja2VyLmpzJykuV2F2UGFja2VyQXVkaW9UeXBlPn1cbiAgICovIGFzeW5jIHNhdmUoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIGlmICghZm9yY2UgJiYgdGhpcy5yZWNvcmRpbmcpIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IHJlY29yZGluZzogcGxlYXNlIGNhbGwgLnBhdXNlKCkgZmlyc3QsIG9yIGNhbGwgLnNhdmUodHJ1ZSkgdG8gZm9yY2UnKTtcbiAgICAgICAgdGhpcy5sb2coJ0V4cG9ydGluZyAuLi4nKTtcbiAgICAgICAgY29uc3QgZXhwb3J0RGF0YSA9IGF3YWl0IHRoaXMuX2V2ZW50KCdleHBvcnQnKTtcbiAgICAgICAgY29uc3QgcGFja2VyID0gbmV3ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2VyLnBhY2sodGhpcy5zYW1wbGVSYXRlLCBleHBvcnREYXRhLmF1ZGlvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIEVuZHMgdGhlIGN1cnJlbnQgcmVjb3JkaW5nIHNlc3Npb24gYW5kIHNhdmVzIHRoZSByZXN1bHRcbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL3dhdl9wYWNrZXIuanMnKS5XYXZQYWNrZXJBdWRpb1R5cGU+fVxuICAgKi8gYXN5bmMgZW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIGNvbnN0IF9wcm9jZXNzb3IgPSB0aGlzLnByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5sb2coJ1N0b3BwaW5nIC4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLl9ldmVudCgnc3RvcCcpO1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0cmFja3MgPSB0aGlzLnN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKT0+dHJhY2suc3RvcCgpKTtcbiAgICAgICAgdGhpcy5sb2coJ0V4cG9ydGluZyAuLi4nKTtcbiAgICAgICAgY29uc3QgZXhwb3J0RGF0YSA9IGF3YWl0IHRoaXMuX2V2ZW50KCdleHBvcnQnLCB7fSwgX3Byb2Nlc3Nvcik7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLm5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmFuYWx5c2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFja2VyID0gbmV3ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2VyLnBhY2sodGhpcy5zYW1wbGVSYXRlLCBleHBvcnREYXRhLmF1ZGlvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZnVsbCBjbGVhbnVwIG9mIFdhdlJlY29yZGVyIGluc3RhbmNlXG4gICAqIFN0b3BzIGFjdGl2ZWx5IGxpc3RlbmluZyB2aWEgbWljcm9waG9uZSBhbmQgcmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyBxdWl0KCkge1xuICAgICAgICB0aGlzLmxpc3RlbkZvckRldmljZUNoYW5nZShudWxsKTtcbiAgICAgICAgLy8gd2UgZG8gbm90IHJlc2V0IHRoaXMgb24gZW5kIHNvIHRoYXQgc2VsZWN0aW9ucyBwZXJzaXN0IGFjcm9zcyBzdGFydHNcbiAgICAgICAgdGhpcy5kZXZpY2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIGF3YWl0IHRoaXMuZW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmdsb2JhbFRoaXMuV2F2UmVjb3JkZXIgPSAkNjJiYzM3NjA0NGEwNTUxMyRleHBvcnQkNDM5YjIxN2NhNjU5YTg3NztcblxuXG5cblxuXG5jbGFzcyAkNWZjMTFkN2JjMGQyMDcyNCRleHBvcnQkMjkzNGNmMmQyNWM2N2E0OCB7XG4gICAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBNZWRpYVN0cmVhbVJlY29yZGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7e3NhbXBsZVJhdGU/OiBudW1iZXIsIG91dHB1dFRvU3BlYWtlcnM/OiBib29sZWFuLCBkZWJ1Zz86IGJvb2xlYW59fSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge01lZGlhU3RyZWFtUmVjb3JkZXJ9XG4gICAqLyBjb25zdHJ1Y3Rvcih7IHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUgPSA0NDEwMCwgb3V0cHV0VG9TcGVha2Vyczogb3V0cHV0VG9TcGVha2VycyA9IGZhbHNlLCBkZWJ1ZzogZGVidWcgPSBmYWxzZSB9ID0ge30pe1xuICAgICAgICAvLyBTY3JpcHQgc291cmNlXG4gICAgICAgIHRoaXMuc2NyaXB0U3JjID0gKDAsICQ4ZTFkMWU2ZmYwOGY2ZmI1JGV4cG9ydCQxZjY1ZjUwYThjYmZmNDNjKTtcbiAgICAgICAgLy8gQ29uZmlnXG4gICAgICAgIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gICAgICAgIHRoaXMub3V0cHV0VG9TcGVha2VycyA9IG91dHB1dFRvU3BlYWtlcnM7XG4gICAgICAgIHRoaXMuZGVidWcgPSAhIWRlYnVnO1xuICAgICAgICAvLyBTdGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRXZlbnQgaGFuZGxpbmcgd2l0aCBBdWRpb1dvcmtsZXRcbiAgICAgICAgdGhpcy5fbGFzdEV2ZW50SWQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50UmVjZWlwdHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFRpbWVvdXQgPSA1MDAwO1xuICAgICAgICAvLyBQcm9jZXNzIGNodW5rcyBvZiBhdWRpb1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvciA9ICgpPT57fTtcbiAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3JTaXplID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlciA9IHtcbiAgICAgICAgICAgIHJhdzogbmV3IEFycmF5QnVmZmVyKDApLFxuICAgICAgICAgICAgbW9ubzogbmV3IEFycmF5QnVmZmVyKDApXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBMb2dzIGRhdGEgaW4gZGVidWcgbW9kZVxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJndW1lbnRzXG4gICAqIEByZXR1cm5zIHt0cnVlfVxuICAgKi8gbG9nKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZykgdGhpcy5sb2coLi4uYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc2FtcGxlUmF0ZSBmb3IgdGhlIHJlY29yZGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqLyBnZXRTYW1wbGVSYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtcImVuZGVkXCJ8XCJwYXVzZWRcInxcInJlY29yZGluZ1wifVxuICAgKi8gZ2V0U3RhdHVzKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSByZXR1cm4gXCJlbmRlZFwiO1xuICAgICAgICBlbHNlIGlmICghdGhpcy5yZWNvcmRpbmcpIHJldHVybiBcInBhdXNlZFwiO1xuICAgICAgICBlbHNlIHJldHVybiBcInJlY29yZGluZ1wiO1xuICAgIH1cbiAgICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIEF1ZGlvV29ya2xldFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3tba2V5OiBzdHJpbmddOiBhbnl9fSBkYXRhXG4gICAqIEBwYXJhbSB7QXVkaW9Xb3JrbGV0Tm9kZX0gW19wcm9jZXNzb3JdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtba2V5OiBzdHJpbmddOiBhbnl9Pn1cbiAgICovIGFzeW5jIF9ldmVudChuYW1lLCBkYXRhID0ge30sIF9wcm9jZXNzb3IgPSBudWxsKSB7XG4gICAgICAgIF9wcm9jZXNzb3IgPSBfcHJvY2Vzc29yIHx8IHRoaXMucHJvY2Vzc29yO1xuICAgICAgICBpZiAoIV9wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2VuZCBldmVudHMgd2l0aG91dCByZWNvcmRpbmcgZmlyc3RcIik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBldmVudDogbmFtZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9sYXN0RXZlbnRJZCsrLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBfcHJvY2Vzc29yLnBvcnQucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHQwID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHdoaWxlKCF0aGlzLmV2ZW50UmVjZWlwdHNbbWVzc2FnZS5pZF0pe1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdDAgPiB0aGlzLmV2ZW50VGltZW91dCkgdGhyb3cgbmV3IEVycm9yKGBUaW1lb3V0IHdhaXRpbmcgZm9yIFwiJHtuYW1lfVwiIGV2ZW50YCk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dCgoKT0+cmVzKHRydWUpLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBCZWdpbnMgYSByZWNvcmRpbmcgc2Vzc2lvbiBmb3IgdGhlIGdpdmVuIGF1ZGlvVHJhY2tcbiAgICogTWljcm9waG9uZSByZWNvcmRpbmcgaW5kaWNhdG9yIHdpbGwgYXBwZWFyIG9uIGJyb3dzZXIgdGFiIGJ1dCBzdGF0dXMgd2lsbCBiZSBcInBhdXNlZFwiXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gW2F1ZGlvVHJhY2tdIGlmIG5vIGRldmljZSBwcm92aWRlZCwgZGVmYXVsdCBkZXZpY2Ugd2lsbCBiZSB1c2VkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgYmVnaW4oYXVkaW9UcmFjaykge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBjb25uZWN0ZWQ6IHBsZWFzZSBjYWxsIC5lbmQoKSB0byBzdGFydCBhIG5ldyBzZXNzaW9uYCk7XG4gICAgICAgIGlmICghYXVkaW9UcmFjayB8fCBhdWRpb1RyYWNrLmtpbmQgIT09IFwiYXVkaW9cIikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXVkaW8gdHJhY2sgcHJvdmlkZWRcIik7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHRoaXMuc2FtcGxlUmF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh0aGlzLnN0cmVhbSk7XG4gICAgICAgIC8vIExvYWQgYW5kIGV4ZWN1dGUgdGhlIG1vZHVsZSBzY3JpcHQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjb250ZXh0LmF1ZGlvV29ya2xldC5hZGRNb2R1bGUodGhpcy5zY3JpcHRTcmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgYWRkIGF1ZGlvV29ya2xldCBtb2R1bGU6ICR7dGhpcy5zY3JpcHRTcmN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gbmV3IEF1ZGlvV29ya2xldE5vZGUoY29udGV4dCwgXCJhdWRpb19wcm9jZXNzb3JcIik7XG4gICAgICAgIHByb2Nlc3Nvci5wb3J0Lm9ubWVzc2FnZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBldmVudDogZXZlbnQsIGlkOiBpZCwgZGF0YTogZGF0YSB9ID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcInJlY2VpcHRcIikgdGhpcy5ldmVudFJlY2VpcHRzW2lkXSA9IGRhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gXCJjaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NodW5rUHJvY2Vzc29yU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikubWVyZ2VCdWZmZXJzKGJ1ZmZlci5yYXcsIGRhdGEucmF3KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbm86ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikubWVyZ2VCdWZmZXJzKGJ1ZmZlci5tb25vLCBkYXRhLm1vbm8pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlci5tb25vLmJ5dGVMZW5ndGggPj0gdGhpcy5fY2h1bmtQcm9jZXNzb3JTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3Nvcih0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IG5ldyBBcnJheUJ1ZmZlcigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5fY2h1bmtQcm9jZXNzb3IoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzb3VyY2UuY29ubmVjdChwcm9jZXNzb3IpO1xuICAgICAgICBjb25zdCBhbmFseXNlciA9IGNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDgxOTI7XG4gICAgICAgIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IDAuMTtcbiAgICAgICAgbm9kZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VG9TcGVha2Vycykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IE91dHB1dCB0byBzcGVha2VycyBtYXkgYWZmZWN0IHNvdW5kIHF1YWxpdHksXFxuZXNwZWNpYWxseSBkdWUgdG8gc3lzdGVtIGF1ZGlvIGZlZWRiYWNrIHByZXZlbnRhdGl2ZSBtZWFzdXJlcy5cXG51c2Ugb25seSBmb3IgZGVidWdnaW5nXCIpO1xuICAgICAgICAgICAgYW5hbHlzZXIuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5hbmFseXNlciA9IGFuYWx5c2VyO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSByZWNvcmRpbmcgdHJhY2tcbiAgICogQHBhcmFtIHtcImZyZXF1ZW5jeVwifFwibXVzaWNcInxcInZvaWNlXCJ9IFthbmFseXNpc1R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRGVjaWJlbHNdIGRlZmF1bHQgLTEwMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heERlY2liZWxzXSBkZWZhdWx0IC0zMFxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2FuYWx5c2lzL2F1ZGlvX2FuYWx5c2lzLmpzJykuQXVkaW9BbmFseXNpc091dHB1dFR5cGV9XG4gICAqLyBnZXRGcmVxdWVuY2llcyhhbmFseXNpc1R5cGUgPSBcImZyZXF1ZW5jeVwiLCBtaW5EZWNpYmVscyA9IC0xMDAsIG1heERlY2liZWxzID0gLTMwKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0XCIpO1xuICAgICAgICByZXR1cm4gKDAsICRmMzJmMDY0NTY0ZWU2MmY2JGV4cG9ydCQyYzMxMzZkYTBiZjEzMGY5KS5nZXRGcmVxdWVuY2llcyh0aGlzLmFuYWx5c2VyLCB0aGlzLnNhbXBsZVJhdGUsIG51bGwsIGFuYWx5c2lzVHlwZSwgbWluRGVjaWJlbHMsIG1heERlY2liZWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBhdXNlcyB0aGUgcmVjb3JkaW5nXG4gICAqIEtlZXBzIG1pY3JvcGhvbmUgc3RyZWFtIG9wZW4gYnV0IGhhbHRzIHN0b3JhZ2Ugb2YgYXVkaW9cbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyBwYXVzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnJlY29yZGluZykgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBwYXVzZWQ6IHBsZWFzZSBjYWxsIC5yZWNvcmQoKSBmaXJzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyLnJhdy5ieXRlTGVuZ3RoKSB0aGlzLl9jaHVua1Byb2Nlc3Nvcih0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlcik7XG4gICAgICAgIHRoaXMubG9nKFwiUGF1c2luZyAuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50KFwic3RvcFwiKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdGFydCByZWNvcmRpbmcgc3RyZWFtIGFuZCBzdG9yaW5nIHRvIG1lbW9yeSBmcm9tIHRoZSBjb25uZWN0ZWQgYXVkaW8gc291cmNlXG4gICAqIEBwYXJhbSB7KGRhdGE6IHsgbW9ubzogSW50MTZBcnJheTsgcmF3OiBJbnQxNkFycmF5IH0pID0+IGFueX0gW2NodW5rUHJvY2Vzc29yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NodW5rU2l6ZV0gY2h1bmtQcm9jZXNzb3Igd2lsbCBub3QgYmUgdHJpZ2dlcmVkIHVudGlsIHRoaXMgc2l6ZSB0aHJlc2hvbGQgbWV0IGluIG1vbm8gYXVkaW9cbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyByZWNvcmQoY2h1bmtQcm9jZXNzb3IgPSAoKT0+e30sIGNodW5rU2l6ZSA9IDgxOTIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVjb3JkaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHJlY29yZGluZzogSEVMTE8gcGxlYXNlIGNhbGwgLnBhdXNlKCkgZmlyc3RcIik7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVua1Byb2Nlc3NvciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoYGNodW5rUHJvY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvbmApO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvciA9IGNodW5rUHJvY2Vzc29yO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUgPSBjaHVua1NpemU7XG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coXCJSZWNvcmRpbmcgLi4uXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9ldmVudChcInN0YXJ0XCIpO1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2xlYXJzIHRoZSBhdWRpbyBidWZmZXIsIGVtcHRpZXMgc3RvcmVkIHJlY29yZGluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIGNsZWFyKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIGVuZGVkOiBwbGVhc2UgY2FsbCAuYmVnaW4oKSBmaXJzdFwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoXCJjbGVhclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZWFkcyB0aGUgY3VycmVudCBhdWRpbyBzdHJlYW0gZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7bWVhblZhbHVlczogRmxvYXQzMkFycmF5LCBjaGFubmVsczogQXJyYXk8RmxvYXQzMkFycmF5Pn0+fVxuICAgKi8gYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIHRoaXMubG9nKFwiUmVhZGluZyAuLi5cIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V2ZW50KFwicmVhZFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IGF1ZGlvIHN0cmVhbSB0byBhIGZpbGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIEZvcmNlIHNhdmluZyB3aGlsZSBzdGlsbCByZWNvcmRpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL3dhdl9wYWNrZXIuanMnKS5XYXZQYWNrZXJBdWRpb1R5cGU+fVxuICAgKi8gYXN5bmMgc2F2ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0XCIpO1xuICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXMucmVjb3JkaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50bHkgcmVjb3JkaW5nOiBwbGVhc2UgY2FsbCAucGF1c2UoKSBmaXJzdCwgb3IgY2FsbCAuc2F2ZSh0cnVlKSB0byBmb3JjZVwiKTtcbiAgICAgICAgdGhpcy5sb2coXCJFeHBvcnRpbmcgLi4uXCIpO1xuICAgICAgICBjb25zdCBleHBvcnREYXRhID0gYXdhaXQgdGhpcy5fZXZlbnQoXCJleHBvcnRcIik7XG4gICAgICAgIGNvbnN0IHBhY2tlciA9IG5ldyAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2tlci5wYWNrKHRoaXMuc2FtcGxlUmF0ZSwgZXhwb3J0RGF0YS5hdWRpbyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBFbmRzIHRoZSBjdXJyZW50IHJlY29yZGluZyBzZXNzaW9uIGFuZCBzYXZlcyB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi93YXZfcGFja2VyLmpzJykuV2F2UGFja2VyQXVkaW9UeXBlPn1cbiAgICovIGFzeW5jIGVuZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIGNvbnN0IF9wcm9jZXNzb3IgPSB0aGlzLnByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5sb2coXCJTdG9wcGluZyAuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50KFwic3RvcFwiKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2coXCJFeHBvcnRpbmcgLi4uXCIpO1xuICAgICAgICBjb25zdCBleHBvcnREYXRhID0gYXdhaXQgdGhpcy5fZXZlbnQoXCJleHBvcnRcIiwge30sIF9wcm9jZXNzb3IpO1xuICAgICAgICB0aGlzLnByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5ub2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhY2tlciA9IG5ldyAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2tlci5wYWNrKHRoaXMuc2FtcGxlUmF0ZSwgZXhwb3J0RGF0YS5hdWRpbyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGZ1bGwgY2xlYW51cCBvZiBXYXZSZWNvcmRlciBpbnN0YW5jZVxuICAgKiBTdG9wcyBhY3RpdmVseSBsaXN0ZW5pbmcgdmlhIG1pY3JvcGhvbmUgYW5kIHJlbW92ZXMgZXhpc3RpbmcgbGlzdGVuZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgcXVpdCgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JEZXZpY2VDaGFuZ2UobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NvcikgYXdhaXQgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZ2xvYmFsVGhpcy5XYXZSZWNvcmRlciA9IFdhdlJlY29yZGVyO1xuXG5cblxuXG52YXIgJDU4ZDE5ZmYwODJhZjVlNWMkZXhwb3J0cyA9IHt9O1xuJDU4ZDE5ZmYwODJhZjVlNWMkZXhwb3J0cyA9IEpTT04ucGFyc2UoXCJ7XFxcIm5hbWVcXFwiOlxcXCJAcGlwZWNhdC1haS9kYWlseS10cmFuc3BvcnRcXFwiLFxcXCJ2ZXJzaW9uXFxcIjpcXFwiMS40LjBcXFwiLFxcXCJsaWNlbnNlXFxcIjpcXFwiQlNELTItQ2xhdXNlXFxcIixcXFwibWFpblxcXCI6XFxcImRpc3QvaW5kZXguanNcXFwiLFxcXCJtb2R1bGVcXFwiOlxcXCJkaXN0L2luZGV4Lm1vZHVsZS5qc1xcXCIsXFxcInR5cGVzXFxcIjpcXFwiZGlzdC9pbmRleC5kLnRzXFxcIixcXFwic291cmNlXFxcIjpcXFwic3JjL2luZGV4LnRzXFxcIixcXFwicmVwb3NpdG9yeVxcXCI6e1xcXCJ0eXBlXFxcIjpcXFwiZ2l0XFxcIixcXFwidXJsXFxcIjpcXFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9waXBlY2F0LWFpL3BpcGVjYXQtY2xpZW50LXdlYi10cmFuc3BvcnRzLmdpdFxcXCJ9LFxcXCJmaWxlc1xcXCI6W1xcXCJkaXN0XFxcIixcXFwicGFja2FnZS5qc29uXFxcIixcXFwiUkVBRE1FLm1kXFxcIl0sXFxcInNjcmlwdHNcXFwiOntcXFwiYnVpbGRcXFwiOlxcXCJwYXJjZWwgYnVpbGQgLS1uby1jYWNoZVxcXCIsXFxcImRldlxcXCI6XFxcInBhcmNlbCB3YXRjaFxcXCIsXFxcImxpbnRcXFwiOlxcXCJlc2xpbnQgLiAtLWV4dCB0cyAtLXJlcG9ydC11bnVzZWQtZGlzYWJsZS1kaXJlY3RpdmVzIC0tbWF4LXdhcm5pbmdzIDBcXFwifSxcXFwiZGV2RGVwZW5kZW5jaWVzXFxcIjp7XFxcIkBwaXBlY2F0LWFpL2NsaWVudC1qc1xcXCI6XFxcIl4xLjQuMFxcXCIsXFxcImVzbGludFxcXCI6XFxcIjkuMTEuMVxcXCIsXFxcImVzbGludC1jb25maWctcHJldHRpZXJcXFwiOlxcXCJeOS4xLjBcXFwiLFxcXCJlc2xpbnQtcGx1Z2luLXNpbXBsZS1pbXBvcnQtc29ydFxcXCI6XFxcIl4xMi4xLjFcXFwifSxcXFwicGVlckRlcGVuZGVuY2llc1xcXCI6e1xcXCJAcGlwZWNhdC1haS9jbGllbnQtanNcXFwiOlxcXCJ+MS40LjBcXFwifSxcXFwiZGVwZW5kZW5jaWVzXFxcIjp7XFxcIkBkYWlseS1jby9kYWlseS1qc1xcXCI6XFxcIl4wLjgzLjFcXFwifSxcXFwiZGVzY3JpcHRpb25cXFwiOlxcXCJQaXBlY2F0IERhaWx5IFRyYW5zcG9ydCBQYWNrYWdlXFxcIixcXFwiYXV0aG9yXFxcIjpcXFwiRGFpbHkuY29cXFwiLFxcXCJidWdzXFxcIjp7XFxcInVybFxcXCI6XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9waXBlY2F0LWFpL3BpcGVjYXQtY2xpZW50LXdlYi10cmFuc3BvcnRzL2lzc3Vlc1xcXCJ9LFxcXCJob21lcGFnZVxcXCI6XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9waXBlY2F0LWFpL3BpcGVjYXQtY2xpZW50LXdlYi10cmFuc3BvcnRzL2Jsb2IvbWFpbi90cmFuc3BvcnRzL2RhaWx5LXdlYnJ0Yy9SRUFETUUubWRcXFwifVwiKTtcblxuXG52YXIgJDY4M2YxMTFmNjFlMDczNTgkZXhwb3J0JGVmMTgwZGU4OGZkMzE3Y2M7XG4oZnVuY3Rpb24oRGFpbHlSVFZJTWVzc2FnZVR5cGUpIHtcbiAgICBEYWlseVJUVklNZXNzYWdlVHlwZVtcIkFVRElPX0JVRkZFUklOR19TVEFSVEVEXCJdID0gXCJhdWRpby1idWZmZXJpbmctc3RhcnRlZFwiO1xuICAgIERhaWx5UlRWSU1lc3NhZ2VUeXBlW1wiQVVESU9fQlVGRkVSSU5HX1NUT1BQRURcIl0gPSBcImF1ZGlvLWJ1ZmZlcmluZy1zdG9wcGVkXCI7XG59KSgkNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkZWYxODBkZTg4ZmQzMTdjYyB8fCAoJDY4M2YxMTFmNjFlMDczNTgkZXhwb3J0JGVmMTgwZGU4OGZkMzE3Y2MgPSB7fSkpO1xuY2xhc3MgJDY4M2YxMTFmNjFlMDczNTgkdmFyJERhaWx5Q2FsbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhaWx5KXtcbiAgICAgICAgdGhpcy5fZGFpbHkgPSBkYWlseTtcbiAgICAgICAgdGhpcy5fcHJveHkgPSBuZXcgUHJveHkodGhpcy5fZGFpbHksIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpPT57XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyTXNnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goU3RyaW5nKHByb3ApKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgbWV0aG9kcyB0aGF0IG1vZGlmeSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBjYWxsLiBUaGVzZSBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcGVyZm9ybWVkIHZpYSB0aGUgUGlwZWNhdENsaWVudCBpbiBvcmRlciB0byBrZWVwIHN0YXRlIGluIHN5bmMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicHJlQXV0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBDYWxscyB0byBwcmVBdXRoKCkgYXJlIGRpc2FibGVkLiBQbGVhc2UgdXNlIFRyYW5zcG9ydC5wcmVBdXRoKClgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0Q2FtZXJhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyTXNnID0gYENhbGxzIHRvIHN0YXJ0Q2FtZXJhKCkgYXJlIGRpc2FibGVkLiBQbGVhc2UgdXNlIFBpcGVjYXRDbGllbnQuaW5pdERldmljZXMoKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiam9pblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBDYWxscyB0byBqb2luKCkgYXJlIGRpc2FibGVkLiBQbGVhc2UgdXNlIFBpcGVjYXRDbGllbnQuY29ubmVjdCgpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWF2ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBDYWxscyB0byBsZWF2ZSgpIGFyZSBkaXNhYmxlZC4gUGxlYXNlIHVzZSBQaXBlY2F0Q2xpZW50LmRpc2Nvbm5lY3QoKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVzdHJveVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBDYWxscyB0byBkZXN0cm95KCkgYXJlIGRpc2FibGVkLmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyck1zZykgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yd2FyZCBvdGhlciBtZXRob2QgY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm94eTtcbiAgICB9XG59XG5jbGFzcyAkNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkYjFjYTk4MmFhMWU0ODhjMSBleHRlbmRzICgwLCAkN3piRDgkVHJhbnNwb3J0KSB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fYm90SWQgPSBcIlwiO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZENhbSA9IHt9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZE1pYyA9IHt9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZFNwZWFrZXIgPSB7fTtcbiAgICAgICAgdGhpcy5fY3VycmVudEF1ZGlvVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9hdWRpb1F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICBjb25zdCB7IGJ1ZmZlckxvY2FsQXVkaW9VbnRpbEJvdFJlYWR5OiBidWZmZXJMb2NhbEF1ZGlvVW50aWxCb3RSZWFkeSwgLi4uZGFpbHlPcHRzIH0gPSBvcHRzO1xuICAgICAgICB0aGlzLl9kYWlseUZhY3RvcnlPcHRpb25zID0gZGFpbHlPcHRzO1xuICAgICAgICAvLyBFbmFibGUgZGV2aWNlIHByZWZlcmVuY2UgY29va2llcyBieSBkZWZhdWx0XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucy5kYWlseUNvbmZpZz8udXNlRGV2aWNlUHJlZmVyZW5jZUNvb2tpZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIHB1cnBvc2VmdWwgPT0gdG8gY2hlY2sgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYWlseUZhY3RvcnlPcHRpb25zLmRhaWx5Q29uZmlnID09IG51bGwpIHRoaXMuX2RhaWx5RmFjdG9yeU9wdGlvbnMuZGFpbHlDb25maWcgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2RhaWx5RmFjdG9yeU9wdGlvbnMuZGFpbHlDb25maWcudXNlRGV2aWNlUHJlZmVyZW5jZUNvb2tpZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlckxvY2FsQXVkaW9VbnRpbEJvdFJlYWR5ID0gYnVmZmVyTG9jYWxBdWRpb1VudGlsQm90UmVhZHkgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX2RhaWx5ID0gKDAsICQ3emJEOCRkYWlseWNvZGFpbHlqcykuY3JlYXRlQ2FsbE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kYWlseUZhY3RvcnlPcHRpb25zLFxuICAgICAgICAgICAgYWxsb3dNdWx0aXBsZUNhbGxJbnN0YW5jZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhaWx5V3JhcHBlciA9IG5ldyAkNjgzZjExMWY2MWUwNzM1OCR2YXIkRGFpbHlDYWxsV3JhcHBlcih0aGlzLl9kYWlseSk7XG4gICAgfVxuICAgIHNldHVwUmVjb3JkZXIoKSB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIgPSBuZXcgKDAsICQ1ZmMxMWQ3YmMwZDIwNzI0JGV4cG9ydCQyOTM0Y2YyZDI1YzY3YTQ4KSh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiAkNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkYjFjYTk4MmFhMWU0ODhjMS5SRUNPUkRFUl9TQU1QTEVfUkFURVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlVXNlckF1ZGlvU3RyZWFtKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fYXVkaW9RdWV1ZS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICBmbHVzaEF1ZGlvUXVldWUoKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwOyAvLyBOdW1iZXIgb2YgYnVmZmVycyB0byBzZW5kIGluIG9uZSBtZXNzYWdlXG4gICAgICAgIGlmICh0aGlzLl9hdWRpb1F1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAoMCwgJDd6YkQ4JGxvZ2dlcikuZGVidWcoYFdpbGwgZmx1c2ggYXVkaW8gcXVldWU6ICR7dGhpcy5fYXVkaW9RdWV1ZS5sZW5ndGh9YCk7XG4gICAgICAgIHdoaWxlKHRoaXMuX2F1ZGlvUXVldWUubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IFtdO1xuICAgICAgICAgICAgLy8gQ29sbGVjdCB1cCB0byBgYmF0Y2hTaXplYCBpdGVtc1xuICAgICAgICAgICAgd2hpbGUoYmF0Y2gubGVuZ3RoIDwgYmF0Y2hTaXplICYmIHRoaXMuX2F1ZGlvUXVldWUubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVkRGF0YSA9IHRoaXMuX2F1ZGlvUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWVkRGF0YSkgYmF0Y2gucHVzaChxdWV1ZWREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAwKSB0aGlzLl9zZW5kQXVkaW9CYXRjaChiYXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbmRBdWRpb0JhdGNoKGRhdGFCYXRjaCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkQmF0Y2ggPSBkYXRhQmF0Y2gubWFwKChkYXRhKT0+e1xuICAgICAgICAgICAgY29uc3QgcGNtQnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnBjbUJ5dGVBcnJheSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXVkaW9NZXNzYWdlID0ge1xuICAgICAgICAgICAgaWQ6IFwicmF3LWF1ZGlvLWJhdGNoXCIsXG4gICAgICAgICAgICBsYWJlbDogXCJydHZpLWFpXCIsXG4gICAgICAgICAgICB0eXBlOiBcInJhdy1hdWRpby1iYXRjaFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGJhc2U2NEF1ZGlvQmF0Y2g6IGVuY29kZWRCYXRjaCxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiAkNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkYjFjYTk4MmFhMWU0ODhjMS5SRUNPUkRFUl9TQU1QTEVfUkFURSxcbiAgICAgICAgICAgICAgICBudW1DaGFubmVsczogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKGF1ZGlvTWVzc2FnZSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUob3B0aW9ucywgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlckxvY2FsQXVkaW9VbnRpbEJvdFJlYWR5KSB0aGlzLnNldHVwUmVjb3JkZXIoKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gb3B0aW9ucy5jYWxsYmFja3MgPz8ge307XG4gICAgICAgIHRoaXMuX29uTWVzc2FnZSA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgICAgICBpZiAodGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucy5zdGFydFZpZGVvT2ZmID09IG51bGwgfHwgb3B0aW9ucy5lbmFibGVDYW0gIT0gbnVsbCkgLy8gRGVmYXVsdCBpcyBjYW0gb2ZmXG4gICAgICAgIHRoaXMuX2RhaWx5RmFjdG9yeU9wdGlvbnMuc3RhcnRWaWRlb09mZiA9ICEob3B0aW9ucy5lbmFibGVDYW0gPz8gZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucy5zdGFydEF1ZGlvT2ZmID09IG51bGwgfHwgb3B0aW9ucy5lbmFibGVNaWMgIT0gbnVsbCkgLy8gRGVmYXVsdCBpcyBtaWMgb25cbiAgICAgICAgdGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucy5zdGFydEF1ZGlvT2ZmID0gIShvcHRpb25zLmVuYWJsZU1pYyA/PyB0cnVlKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICAgICAgKDAsICQ3emJEOCRsb2dnZXIpLmRlYnVnKFwiW0RhaWx5IFRyYW5zcG9ydF0gSW5pdGlhbGl6ZWRcIiwgKDAsICgvKkBfX1BVUkVfXyovJHBhcmNlbCRpbnRlcm9wRGVmYXVsdCgkNThkMTlmZjA4MmFmNWU1YyRleHBvcnRzKSkpLnZlcnNpb24pO1xuICAgIH1cbiAgICBnZXQgZGFpbHlDYWxsQ2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGFpbHlXcmFwcGVyLnByb3h5O1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgc2V0IHN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gc3RhdGUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uVHJhbnNwb3J0U3RhdGVDaGFuZ2VkPy4oc3RhdGUpO1xuICAgIH1cbiAgICBnZXRTZXNzaW9uSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhaWx5Lm1lZXRpbmdTZXNzaW9uU3VtbWFyeSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBbGxDYW1zKCkge1xuICAgICAgICBjb25zdCB7IGRldmljZXM6IGRldmljZXMgfSA9IGF3YWl0IHRoaXMuX2RhaWx5LmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKChkKT0+ZC5raW5kID09PSBcInZpZGVvaW5wdXRcIik7XG4gICAgfVxuICAgIHVwZGF0ZUNhbShjYW1JZCkge1xuICAgICAgICB0aGlzLl9kYWlseS5zZXRJbnB1dERldmljZXNBc3luYyh7XG4gICAgICAgICAgICB2aWRlb0RldmljZUlkOiBjYW1JZFxuICAgICAgICB9KS50aGVuKChpbmZvcyk9PntcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkQ2FtID0gaW5mb3MuY2FtZXJhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkQ2FtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDYW07XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbE1pY3MoKSB7XG4gICAgICAgIGNvbnN0IHsgZGV2aWNlczogZGV2aWNlcyB9ID0gYXdhaXQgdGhpcy5fZGFpbHkuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGQpPT5kLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiKTtcbiAgICB9XG4gICAgdXBkYXRlTWljKG1pY0lkKSB7XG4gICAgICAgIHRoaXMuX2RhaWx5LnNldElucHV0RGV2aWNlc0FzeW5jKHtcbiAgICAgICAgICAgIGF1ZGlvRGV2aWNlSWQ6IG1pY0lkXG4gICAgICAgIH0pLnRoZW4oKGluZm9zKT0+e1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRNaWMgPSBpbmZvcy5taWM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRNaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZE1pYztcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWxsU3BlYWtlcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZGV2aWNlczogZGV2aWNlcyB9ID0gYXdhaXQgdGhpcy5fZGFpbHkuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGQpPT5kLmtpbmQgPT09IFwiYXVkaW9vdXRwdXRcIik7XG4gICAgfVxuICAgIHVwZGF0ZVNwZWFrZXIoc3BlYWtlcklkKSB7XG4gICAgICAgIHRoaXMuX2RhaWx5LnNldE91dHB1dERldmljZUFzeW5jKHtcbiAgICAgICAgICAgIG91dHB1dERldmljZUlkOiBzcGVha2VySWRcbiAgICAgICAgfSkudGhlbigoaW5mb3MpPT57XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFNwZWFrZXIgPSBpbmZvcy5zcGVha2VyO1xuICAgICAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkRldmljZUVycm9yPy4obmV3ICgwLCAkN3piRDgkRGV2aWNlRXJyb3IpKFtcbiAgICAgICAgICAgICAgICBcInNwZWFrZXJcIlxuICAgICAgICAgICAgXSwgZS50eXBlID8/IFwidW5rbm93blwiLCBlLm1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZFNwZWFrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZFNwZWFrZXI7XG4gICAgfVxuICAgIGVuYWJsZU1pYyhlbmFibGUpIHtcbiAgICAgICAgdGhpcy5fZGFpbHkuc2V0TG9jYWxBdWRpbyhlbmFibGUpO1xuICAgIH1cbiAgICBnZXQgaXNNaWNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGFpbHkubG9jYWxBdWRpbygpO1xuICAgIH1cbiAgICBlbmFibGVDYW0oZW5hYmxlKSB7XG4gICAgICAgIHRoaXMuX2RhaWx5LnNldExvY2FsVmlkZW8oZW5hYmxlKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FtRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhaWx5LmxvY2FsVmlkZW8oKTtcbiAgICB9XG4gICAgZW5hYmxlU2NyZWVuU2hhcmUoZW5hYmxlKSB7XG4gICAgICAgIGlmIChlbmFibGUpIHRoaXMuX2RhaWx5LnN0YXJ0U2NyZWVuU2hhcmUoKTtcbiAgICAgICAgZWxzZSB0aGlzLl9kYWlseS5zdG9wU2NyZWVuU2hhcmUoKTtcbiAgICB9XG4gICAgZ2V0IGlzU2hhcmluZ1NjcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhaWx5LmxvY2FsU2NyZWVuQXVkaW8oKSB8fCB0aGlzLl9kYWlseS5sb2NhbFNjcmVlblZpZGVvKCk7XG4gICAgfVxuICAgIHRyYWNrcygpIHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnRzID0gdGhpcy5fZGFpbHkucGFydGljaXBhbnRzKCkgPz8ge307XG4gICAgICAgIGNvbnN0IGJvdCA9IHBhcnRpY2lwYW50cz8uW3RoaXMuX2JvdElkXTtcbiAgICAgICAgY29uc3QgdHJhY2tzID0ge1xuICAgICAgICAgICAgbG9jYWw6IHtcbiAgICAgICAgICAgICAgICBhdWRpbzogcGFydGljaXBhbnRzPy5sb2NhbD8udHJhY2tzPy5hdWRpbz8ucGVyc2lzdGVudFRyYWNrLFxuICAgICAgICAgICAgICAgIHNjcmVlbkF1ZGlvOiBwYXJ0aWNpcGFudHM/LmxvY2FsPy50cmFja3M/LnNjcmVlbkF1ZGlvPy5wZXJzaXN0ZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgc2NyZWVuVmlkZW86IHBhcnRpY2lwYW50cz8ubG9jYWw/LnRyYWNrcz8uc2NyZWVuVmlkZW8/LnBlcnNpc3RlbnRUcmFjayxcbiAgICAgICAgICAgICAgICB2aWRlbzogcGFydGljaXBhbnRzPy5sb2NhbD8udHJhY2tzPy52aWRlbz8ucGVyc2lzdGVudFRyYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChib3QpIHRyYWNrcy5ib3QgPSB7XG4gICAgICAgICAgICBhdWRpbzogYm90Py50cmFja3M/LmF1ZGlvPy5wZXJzaXN0ZW50VHJhY2ssXG4gICAgICAgICAgICB2aWRlbzogYm90Py50cmFja3M/LnZpZGVvPy5wZXJzaXN0ZW50VHJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyYWNrcztcbiAgICB9XG4gICAgYXN5bmMgc3RhcnRSZWNvcmRpbmcoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAoMCwgJDd6YkQ4JGxvZ2dlcikuaW5mbyhcIltEYWlseSBUcmFuc3BvcnRdIEluaXRpYWxpemluZyByZWNvcmRpbmdcIik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyLnJlY29yZCgoZGF0YSk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVzZXJBdWRpb1N0cmVhbShkYXRhLm1vbm8pO1xuICAgICAgICAgICAgfSwgJDY4M2YxMTFmNjFlMDczNTgkZXhwb3J0JGIxY2E5ODJhYTFlNDg4YzEuUkVDT1JERVJfQ0hVTktfU0laRSk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25BdWRpb0J1ZmZlcmluZ1N0YXJ0ZWQ/LigpO1xuICAgICAgICAgICAgKDAsICQ3emJEOCRsb2dnZXIpLmluZm8oXCJbRGFpbHkgVHJhbnNwb3J0XSBSZWNvcmRpbmcgSW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGU7XG4gICAgICAgICAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKFwiQWxyZWFkeSByZWNvcmRpbmdcIikpICgwLCAkN3piRDgkbG9nZ2VyKS5lcnJvcihcIkVycm9yIHN0YXJ0aW5nIHJlY29yZGluZ1wiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcmVBdXRoKGRhaWx5Q2FsbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucyA9IGRhaWx5Q2FsbE9wdGlvbnM7XG4gICAgICAgIGF3YWl0IHRoaXMuX2RhaWx5LnByZUF1dGgoZGFpbHlDYWxsT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGluaXREZXZpY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RhaWx5KSB0aHJvdyBuZXcgKDAsICQ3emJEOCRSVFZJRXJyb3IpKFwiVHJhbnNwb3J0IGluc3RhbmNlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6aW5nXCI7XG4gICAgICAgIGNvbnN0IGluZm9zID0gYXdhaXQgdGhpcy5fZGFpbHkuc3RhcnRDYW1lcmEodGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZGV2aWNlczogZGV2aWNlcyB9ID0gYXdhaXQgdGhpcy5fZGFpbHkuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICBjb25zdCBjYW1zID0gZGV2aWNlcy5maWx0ZXIoKGQpPT5kLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiKTtcbiAgICAgICAgY29uc3QgbWljcyA9IGRldmljZXMuZmlsdGVyKChkKT0+ZC5raW5kID09PSBcImF1ZGlvaW5wdXRcIik7XG4gICAgICAgIGNvbnN0IHNwZWFrZXJzID0gZGV2aWNlcy5maWx0ZXIoKGQpPT5kLmtpbmQgPT09IFwiYXVkaW9vdXRwdXRcIik7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkQ2FtID0gaW5mb3MuY2FtZXJhO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZE1pYyA9IGluZm9zLm1pYztcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRTcGVha2VyID0gaW5mb3Muc3BlYWtlcjtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uQXZhaWxhYmxlQ2Ftc1VwZGF0ZWQ/LihjYW1zKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uQXZhaWxhYmxlTWljc1VwZGF0ZWQ/LihtaWNzKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uQXZhaWxhYmxlU3BlYWtlcnNVcGRhdGVkPy4oc3BlYWtlcnMpO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25DYW1VcGRhdGVkPy4oaW5mb3MuY2FtZXJhKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uTWljVXBkYXRlZD8uKGluZm9zLm1pYyk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vblNwZWFrZXJVcGRhdGVkPy4oaW5mb3Muc3BlYWtlcik7XG4gICAgICAgIC8vIEluc3RhbnRpYXRlIGF1ZGlvIG9ic2VydmVyc1xuICAgICAgICBpZiAoIXRoaXMuX2RhaWx5LmlzTG9jYWxBdWRpb0xldmVsT2JzZXJ2ZXJSdW5uaW5nKCkpIGF3YWl0IHRoaXMuX2RhaWx5LnN0YXJ0TG9jYWxBdWRpb0xldmVsT2JzZXJ2ZXIoMTAwKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYWlseS5pc1JlbW90ZVBhcnRpY2lwYW50c0F1ZGlvTGV2ZWxPYnNlcnZlclJ1bm5pbmcoKSkgYXdhaXQgdGhpcy5fZGFpbHkuc3RhcnRSZW1vdGVQYXJ0aWNpcGFudHNBdWRpb0xldmVsT2JzZXJ2ZXIoMTAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6ZWRcIjtcbiAgICB9XG4gICAgX3ZhbGlkYXRlQ29ubmVjdGlvblBhcmFtcyhjb25uZWN0UGFyYW1zKSB7XG4gICAgICAgIGlmIChjb25uZWN0UGFyYW1zID09PSB1bmRlZmluZWQgfHwgY29ubmVjdFBhcmFtcyA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0UGFyYW1zICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgKDAsICQ3emJEOCRSVFZJRXJyb3IpKFwiSW52YWxpZCBjb25uZWN0aW9uIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIGNvbnN0IHRtcFBhcmFtcyA9IGNvbm5lY3RQYXJhbXM7XG4gICAgICAgIGlmICh0bXBQYXJhbXMucm9vbV91cmwpIHtcbiAgICAgICAgICAgIHRtcFBhcmFtcy51cmwgPSB0bXBQYXJhbXMucm9vbV91cmw7XG4gICAgICAgICAgICBkZWxldGUgdG1wUGFyYW1zLnJvb21fdXJsO1xuICAgICAgICB9IGVsc2UgaWYgKHRtcFBhcmFtcy5kYWlseVJvb20pIHtcbiAgICAgICAgICAgIHRtcFBhcmFtcy51cmwgPSB0bXBQYXJhbXMuZGFpbHlSb29tO1xuICAgICAgICAgICAgZGVsZXRlIHRtcFBhcmFtcy5kYWlseVJvb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRtcFBhcmFtcy5kYWlseVRva2VuKSB7XG4gICAgICAgICAgICB0bXBQYXJhbXMudG9rZW4gPSB0bXBQYXJhbXMuZGFpbHlUb2tlbjtcbiAgICAgICAgICAgIGRlbGV0ZSB0bXBQYXJhbXMuZGFpbHlUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRtcFBhcmFtcy50b2tlbikgLy8gRGFpbHkgZG9lc24ndCBsaWtlIHRva2VuIGJlaW5nIGluIHRoZSBtYXAgYW5kIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIGRlbGV0ZSB0bXBQYXJhbXMudG9rZW47XG4gICAgICAgIHJldHVybiB0bXBQYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIF9jb25uZWN0KGNvbm5lY3RQYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kYWlseSkgdGhyb3cgbmV3ICgwLCAkN3piRDgkUlRWSUVycm9yKShcIlRyYW5zcG9ydCBpbnN0YW5jZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIGlmIChjb25uZWN0UGFyYW1zKSB0aGlzLl9kYWlseUZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5fZGFpbHlGYWN0b3J5T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmNvbm5lY3RQYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiY29ubmVjdGluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGFpbHkuam9pbih0aGlzLl9kYWlseUZhY3RvcnlPcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgKDAsICQ3emJEOCRsb2dnZXIpLmVycm9yKFwiRmFpbGVkIHRvIGpvaW4gcm9vbVwiLCBlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImVycm9yXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgKDAsICQ3emJEOCRUcmFuc3BvcnRTdGFydEVycm9yKSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXI/LnNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImNvbm5lY3RlZFwiO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25Db25uZWN0ZWQ/LigpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kUmVhZHlNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgICAgICAvLyBEZXRlY3QgaU9TIGRldmljZXNcbiAgICAgICAgICAgIGNvbnN0IGlzSU9TID0gKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdCh1c2VyQWdlbnQpIHx8IC9NYWNpbnRvc2gvLnRlc3QodXNlckFnZW50KSAmJiBcIm9udG91Y2hlbmRcIiBpbiBkb2N1bWVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzZW5kUmVhZHlNZXNzYWdlID0gKCk9PntcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBjaGFuZ2luZyB0byBtYXRjaCB0aGUgaU9TL0FuZHJvaWQgU0RLcyB3aGVyZVxuICAgICAgICAgICAgICAgIC8vICAgICAgIHdlIGRvbid0IGFjdHVhbGx5IHNldCBvdXIgc3RhdGUgdG8gXCJyZWFkeVwiIHVudGlsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgd2UndmUgcmVjZWl2ZWQgdGhlIGJvdF9yZWFkeSBzaWduYWxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJyZWFkeVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hBdWRpb1F1ZXVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSgoMCwgJDd6YkQ4JFJUVklNZXNzYWdlKS5jbGllbnRSZWFkeSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yKGNvbnN0IGlkIGluIHRoaXMuX2RhaWx5LnBhcnRpY2lwYW50cygpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fZGFpbHkucGFydGljaXBhbnRzKClbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghcC5sb2NhbCAmJiBwLnRyYWNrcz8uYXVkaW8/LnBlcnNpc3RlbnRUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSByZW1vdGUgYXVkaW8gdHJhY2ssIHdlIGNhbiBzZW5kIHRoZSByZWFkeSBtZXNzYWdlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZWFkeU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKGV2KT0+e1xuICAgICAgICAgICAgICAgIGlmICghZXYucGFydGljaXBhbnQ/LmxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhaWx5Lm9mZihcInRyYWNrLXN0YXJ0ZWRcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBpT1MgZGV2aWNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lPUygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgJDd6YkQ4JGxvZ2dlcikuZGVidWcoXCJbRGFpbHkgVHJhbnNwb3J0XSBpT1MgZGV2aWNlIGRldGVjdGVkLCBhZGRpbmcgMC41IHNlY29uZCBkZWxheSBiZWZvcmUgc2VuZGluZyByZWFkeSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIDUwMG1zIGRlbGF5IGZvciBpT1MgZGV2aWNlczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBpT1MgZGV2aWNlcyBjbGlwcGluZyBhIHBvcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBhdWRpbyBhZnRlciB0aGUgdHJhY2sgYmVjb21lcyBwbGF5YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2VuZFJlYWR5TWVzc2FnZSwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIE5vbi1pT1MgZGV2aWNlLCBzZW5kIHJlYWR5IG1lc3NhZ2UgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlYWR5TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9kYWlseS5vbihcInRyYWNrLXN0YXJ0ZWRcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BSZWNvcmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyICYmIHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuZ2V0U3RhdHVzKCkgIT09IFwiZW5kZWRcIikge1xuICAgICAgICAgICAgLy8gZGlzY29ubmVjdGluZywgd2UgZG9uJ3QgbmVlZCB0byByZWNvcmQgYW55bW9yZVxuICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1SZWNvcmRlci5lbmQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkF1ZGlvQnVmZmVyaW5nU3RvcHBlZD8uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2RhaWx5Lm9uKFwiYXZhaWxhYmxlLWRldmljZXMtdXBkYXRlZFwiLCB0aGlzLmhhbmRsZUF2YWlsYWJsZURldmljZXNVcGRhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kYWlseS5vbihcInNlbGVjdGVkLWRldmljZXMtdXBkYXRlZFwiLCB0aGlzLmhhbmRsZVNlbGVjdGVkRGV2aWNlc1VwZGF0ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RhaWx5Lm9uKFwiY2FtZXJhLWVycm9yXCIsIHRoaXMuaGFuZGxlRGV2aWNlRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RhaWx5Lm9uKFwidHJhY2stc3RhcnRlZFwiLCB0aGlzLmhhbmRsZVRyYWNrU3RhcnRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZGFpbHkub24oXCJ0cmFjay1zdG9wcGVkXCIsIHRoaXMuaGFuZGxlVHJhY2tTdG9wcGVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kYWlseS5vbihcInBhcnRpY2lwYW50LWpvaW5lZFwiLCB0aGlzLmhhbmRsZVBhcnRpY2lwYW50Sm9pbmVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kYWlseS5vbihcInBhcnRpY2lwYW50LWxlZnRcIiwgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudExlZnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RhaWx5Lm9uKFwibG9jYWwtYXVkaW8tbGV2ZWxcIiwgdGhpcy5oYW5kbGVMb2NhbEF1ZGlvTGV2ZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RhaWx5Lm9uKFwicmVtb3RlLXBhcnRpY2lwYW50cy1hdWRpby1sZXZlbFwiLCB0aGlzLmhhbmRsZVJlbW90ZUF1ZGlvTGV2ZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RhaWx5Lm9uKFwiYXBwLW1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVBcHBNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kYWlseS5vbihcImxlZnQtbWVldGluZ1wiLCB0aGlzLmhhbmRsZUxlZnRNZWV0aW5nLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kYWlseS5vbihcImVycm9yXCIsIHRoaXMuaGFuZGxlRmF0YWxFcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZGFpbHkub24oXCJub25mYXRhbC1lcnJvclwiLCB0aGlzLmhhbmRsZU5vbkZhdGFsRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGFzeW5jIF9kaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJkaXNjb25uZWN0aW5nXCI7XG4gICAgICAgIHRoaXMuX2RhaWx5LnN0b3BMb2NhbEF1ZGlvTGV2ZWxPYnNlcnZlcigpO1xuICAgICAgICB0aGlzLl9kYWlseS5zdG9wUmVtb3RlUGFydGljaXBhbnRzQXVkaW9MZXZlbE9ic2VydmVyKCk7XG4gICAgICAgIHRoaXMuX2F1ZGlvUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fY3VycmVudEF1ZGlvVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZGFpbHkubGVhdmUoKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9kYWlseS5zZW5kQXBwTWVzc2FnZShtZXNzYWdlLCBcIipcIik7XG4gICAgfVxuICAgIGhhbmRsZUFwcE1lc3NhZ2UoZXYpIHtcbiAgICAgICAgLy8gQnViYmxlIGFueSBtZXNzYWdlcyB3aXRoIHJ0dmktYWkgbGFiZWxcbiAgICAgICAgaWYgKGV2LmRhdGEubGFiZWwgPT09IFwicnR2aS1haVwiKSB0aGlzLl9vbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IGV2LmRhdGEuaWQsXG4gICAgICAgICAgICB0eXBlOiBldi5kYXRhLnR5cGUsXG4gICAgICAgICAgICBkYXRhOiBldi5kYXRhLmRhdGFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUF2YWlsYWJsZURldmljZXNVcGRhdGVkKGV2KSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkF2YWlsYWJsZUNhbXNVcGRhdGVkPy4oZXYuYXZhaWxhYmxlRGV2aWNlcy5maWx0ZXIoKGQpPT5kLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiKSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkF2YWlsYWJsZU1pY3NVcGRhdGVkPy4oZXYuYXZhaWxhYmxlRGV2aWNlcy5maWx0ZXIoKGQpPT5kLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiKSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkF2YWlsYWJsZVNwZWFrZXJzVXBkYXRlZD8uKGV2LmF2YWlsYWJsZURldmljZXMuZmlsdGVyKChkKT0+ZC5raW5kID09PSBcImF1ZGlvb3V0cHV0XCIpKTtcbiAgICB9XG4gICAgaGFuZGxlU2VsZWN0ZWREZXZpY2VzVXBkYXRlZChldikge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRDYW0/LmRldmljZUlkICE9PSBldi5kZXZpY2VzLmNhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRDYW0gPSBldi5kZXZpY2VzLmNhbWVyYTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkNhbVVwZGF0ZWQ/Lihldi5kZXZpY2VzLmNhbWVyYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkTWljPy5kZXZpY2VJZCAhPT0gZXYuZGV2aWNlcy5taWMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkTWljID0gZXYuZGV2aWNlcy5taWM7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25NaWNVcGRhdGVkPy4oZXYuZGV2aWNlcy5taWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFNwZWFrZXI/LmRldmljZUlkICE9PSBldi5kZXZpY2VzLnNwZWFrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkU3BlYWtlciA9IGV2LmRldmljZXMuc3BlYWtlcjtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vblNwZWFrZXJVcGRhdGVkPy4oZXYuZGV2aWNlcy5zcGVha2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEZXZpY2VFcnJvcihldikge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZURldmljZUVycm9yID0gKGVycm9yKT0+e1xuICAgICAgICAgICAgY29uc3QgZGV2aWNlcyA9IFtdO1xuICAgICAgICAgICAgc3dpdGNoKGVycm9yLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwZXJtaXNzaW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICBlcnJvci5ibG9ja2VkTWVkaWEuZm9yRWFjaCgoZCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXMucHVzaChkID09PSBcInZpZGVvXCIgPyBcImNhbVwiIDogXCJtaWNcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkN3piRDgkRGV2aWNlRXJyb3IpKGRldmljZXMsIGVycm9yLnR5cGUsIGVycm9yLm1zZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tlZEJ5OiBlcnJvci5ibG9ja2VkQnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdC1mb3VuZFwiOlxuICAgICAgICAgICAgICAgICAgICBlcnJvci5taXNzaW5nTWVkaWEuZm9yRWFjaCgoZCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXMucHVzaChkID09PSBcInZpZGVvXCIgPyBcImNhbVwiIDogXCJtaWNcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkN3piRDgkRGV2aWNlRXJyb3IpKGRldmljZXMsIGVycm9yLnR5cGUsIGVycm9yLm1zZyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cmFpbnRzXCI6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmZhaWxlZE1lZGlhLmZvckVhY2goKGQpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzLnB1c2goZCA9PT0gXCJ2aWRlb1wiID8gXCJjYW1cIiA6IFwibWljXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDd6YkQ4JERldmljZUVycm9yKShkZXZpY2VzLCBlcnJvci50eXBlLCBlcnJvci5tc2csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IucmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjYW0taW4tdXNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRldmljZXMucHVzaChcImNhbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDd6YkQ4JERldmljZUVycm9yKShkZXZpY2VzLCBcImluLXVzZVwiLCBlcnJvci5tc2cpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtaWMtaW4tdXNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRldmljZXMucHVzaChcIm1pY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDd6YkQ4JERldmljZUVycm9yKShkZXZpY2VzLCBcImluLXVzZVwiLCBlcnJvci5tc2cpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjYW0tbWljLWluLXVzZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VzLnB1c2goXCJjYW1cIik7XG4gICAgICAgICAgICAgICAgICAgIGRldmljZXMucHVzaChcIm1pY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDd6YkQ4JERldmljZUVycm9yKShkZXZpY2VzLCBcImluLXVzZVwiLCBlcnJvci5tc2cpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtbWVkaWFkZXZpY2VzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VzLnB1c2goXCJjYW1cIik7XG4gICAgICAgICAgICAgICAgICAgIGRldmljZXMucHVzaChcIm1pY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDd6YkQ4JERldmljZUVycm9yKShkZXZpY2VzLCBlcnJvci50eXBlLCBlcnJvci5tc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25EZXZpY2VFcnJvcj8uKGdlbmVyYXRlRGV2aWNlRXJyb3IoZXYuZXJyb3IpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFwicmVhZHlcIiB8fCAhdGhpcy5fYnVmZmVyTG9jYWxBdWRpb1VudGlsQm90UmVhZHkpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5fbWVkaWFTdHJlYW1SZWNvcmRlci5nZXRTdGF0dXMoKTtcbiAgICAgICAgc3dpdGNoKHN0YXR1cyl7XG4gICAgICAgICAgICBjYXNlIFwiZW5kZWRcIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyLmJlZ2luKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB2b2lkLiBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzZWRcIjpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVjb3JkaW5nXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QXVkaW9UcmFjayAhPT0gdHJhY2spIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuYmVnaW4odHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHZvaWQuIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgKDAsICQ3emJEOCRsb2dnZXIpLndhcm4oXCJ0cmFjay1zdGFydGVkIGV2ZW50IHJlY2VpdmVkIGZvciBjdXJyZW50IHRyYWNrIGFuZCBhbHJlYWR5IHJlY29yZGluZ1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50QXVkaW9UcmFjayA9IHRyYWNrO1xuICAgIH1cbiAgICBoYW5kbGVUcmFja1N0YXJ0ZWQoZXYpIHtcbiAgICAgICAgaWYgKGV2LnR5cGUgPT09IFwic2NyZWVuQXVkaW9cIiB8fCBldi50eXBlID09PSBcInNjcmVlblZpZGVvXCIpIHRoaXMuX2NhbGxiYWNrcy5vblNjcmVlblRyYWNrU3RhcnRlZD8uKGV2LnRyYWNrLCBldi5wYXJ0aWNpcGFudCA/ICQ2ODNmMTExZjYxZTA3MzU4JHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudChldi5wYXJ0aWNpcGFudCkgOiB1bmRlZmluZWQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChldi5wYXJ0aWNpcGFudD8ubG9jYWwgJiYgZXYudHJhY2sua2luZCA9PT0gXCJhdWRpb1wiKSB0aGlzLmhhbmRsZUxvY2FsQXVkaW9UcmFjayhldi50cmFjayk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25UcmFja1N0YXJ0ZWQ/Lihldi50cmFjaywgZXYucGFydGljaXBhbnQgPyAkNjgzZjExMWY2MWUwNzM1OCR2YXIkZGFpbHlQYXJ0aWNpcGFudFRvUGFydGljaXBhbnQoZXYucGFydGljaXBhbnQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVUcmFja1N0b3BwZWQoZXYpIHtcbiAgICAgICAgaWYgKGV2LnR5cGUgPT09IFwic2NyZWVuQXVkaW9cIiB8fCBldi50eXBlID09PSBcInNjcmVlblZpZGVvXCIpIHRoaXMuX2NhbGxiYWNrcy5vblNjcmVlblRyYWNrU3RvcHBlZD8uKGV2LnRyYWNrLCBldi5wYXJ0aWNpcGFudCA/ICQ2ODNmMTExZjYxZTA3MzU4JHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudChldi5wYXJ0aWNpcGFudCkgOiB1bmRlZmluZWQpO1xuICAgICAgICBlbHNlIHRoaXMuX2NhbGxiYWNrcy5vblRyYWNrU3RvcHBlZD8uKGV2LnRyYWNrLCBldi5wYXJ0aWNpcGFudCA/ICQ2ODNmMTExZjYxZTA3MzU4JHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudChldi5wYXJ0aWNpcGFudCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBoYW5kbGVQYXJ0aWNpcGFudEpvaW5lZChldikge1xuICAgICAgICBjb25zdCBwID0gJDY4M2YxMTFmNjFlMDczNTgkdmFyJGRhaWx5UGFydGljaXBhbnRUb1BhcnRpY2lwYW50KGV2LnBhcnRpY2lwYW50KTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uUGFydGljaXBhbnRKb2luZWQ/LihwKTtcbiAgICAgICAgaWYgKHAubG9jYWwpIHJldHVybjtcbiAgICAgICAgdGhpcy5fYm90SWQgPSBldi5wYXJ0aWNpcGFudC5zZXNzaW9uX2lkO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25Cb3RDb25uZWN0ZWQ/LihwKTtcbiAgICB9XG4gICAgaGFuZGxlUGFydGljaXBhbnRMZWZ0KGV2KSB7XG4gICAgICAgIGNvbnN0IHAgPSAkNjgzZjExMWY2MWUwNzM1OCR2YXIkZGFpbHlQYXJ0aWNpcGFudFRvUGFydGljaXBhbnQoZXYucGFydGljaXBhbnQpO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25QYXJ0aWNpcGFudExlZnQ/LihwKTtcbiAgICAgICAgaWYgKHAubG9jYWwpIHJldHVybjtcbiAgICAgICAgdGhpcy5fYm90SWQgPSBcIlwiO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25Cb3REaXNjb25uZWN0ZWQ/LihwKTtcbiAgICB9XG4gICAgaGFuZGxlTG9jYWxBdWRpb0xldmVsKGV2KSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkxvY2FsQXVkaW9MZXZlbD8uKGV2LmF1ZGlvTGV2ZWwpO1xuICAgIH1cbiAgICBoYW5kbGVSZW1vdGVBdWRpb0xldmVsKGV2KSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHRoaXMuX2RhaWx5LnBhcnRpY2lwYW50cygpO1xuICAgICAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhldi5wYXJ0aWNpcGFudHNBdWRpb0xldmVsKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsID0gZXYucGFydGljaXBhbnRzQXVkaW9MZXZlbFtpZF07XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25SZW1vdGVBdWRpb0xldmVsPy4obGV2ZWwsICQ2ODNmMTExZjYxZTA3MzU4JHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudChwYXJ0aWNpcGFudHNbaWRdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTGVmdE1lZXRpbmcoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgICAgICB0aGlzLl9ib3RJZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkRpc2Nvbm5lY3RlZD8uKCk7XG4gICAgfVxuICAgIGhhbmRsZUZhdGFsRXJyb3IoZXYpIHtcbiAgICAgICAgKDAsICQ3emJEOCRsb2dnZXIpLmVycm9yKFwiRGFpbHkgZmF0YWwgZXJyb3JcIiwgZXYuZXJyb3JNc2cpO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJlcnJvclwiO1xuICAgICAgICB0aGlzLl9ib3RJZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkVycm9yPy4oKDAsICQ3emJEOCRSVFZJTWVzc2FnZSkuZXJyb3IoZXYuZXJyb3JNc2csIHRydWUpKTtcbiAgICB9XG4gICAgaGFuZGxlTm9uRmF0YWxFcnJvcihldikge1xuICAgICAgICBzd2l0Y2goZXYudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwic2NyZWVuLXNoYXJlLWVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uU2NyZWVuU2hhcmVFcnJvcj8uKGV2LmVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbiQ2ODNmMTExZjYxZTA3MzU4JGV4cG9ydCRiMWNhOTgyYWExZTQ4OGMxLlJFQ09SREVSX1NBTVBMRV9SQVRFID0gMTYwMDA7XG4kNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkYjFjYTk4MmFhMWU0ODhjMS5SRUNPUkRFUl9DSFVOS19TSVpFID0gNTEyO1xuY29uc3QgJDY4M2YxMTFmNjFlMDczNTgkdmFyJGRhaWx5UGFydGljaXBhbnRUb1BhcnRpY2lwYW50ID0gKHApPT4oe1xuICAgICAgICBpZDogcC51c2VyX2lkLFxuICAgICAgICBsb2NhbDogcC5sb2NhbCxcbiAgICAgICAgbmFtZTogcC51c2VyX25hbWVcbiAgICB9KTtcblxuXG5cblxuZXhwb3J0IHskNjgzZjExMWY2MWUwNzM1OCRleHBvcnQkZWYxODBkZTg4ZmQzMTdjYyBhcyBEYWlseVJUVklNZXNzYWdlVHlwZSwgJDY4M2YxMTFmNjFlMDczNTgkZXhwb3J0JGIxY2E5ODJhYTFlNDg4YzEgYXMgRGFpbHlUcmFuc3BvcnR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@pipecat-ai+daily-transport@1.4.1_@pipecat-ai+client-js@1.4.1/node_modules/@pipecat-ai/daily-transport/dist/index.module.js\n");

/***/ })

};
;